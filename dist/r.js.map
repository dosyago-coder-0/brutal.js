{"version":3,"sources":["common.js","node_modules/base64-js/index.js","node_modules/ieee754/index.js","node_modules/isarray/index.js","node_modules/buffer/index.js","t.js","types.js","r.js"],"names":["CODE","Math","random","BROWSER_SIDE","self","DOMParser","e","BuiltIns","Symbol","Boolean","Number","String","Object","Set","Map","WeakMap","WeakSet","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8ClampedArray","Node","NodeList","Element","HTMLElement","Blob","ArrayBuffer","FileList","Text","HTMLDocument","Document","DocumentFragment","Error","File","Event","EventTarget","URL","Buffer","DEBUG","SEALED_DEFAULT","isNone","instance","undefined","typeCache","T","parts","vals","cooked","typeName","reduce","prev","cur","i","has","TypeError","get","type","partialMatch","validate","partial","guardType","guardExists","name","spec","kind","help","verify","verifiers","sealed","specKeyPaths","allKeyPaths","sort","specKeyPathSet","bigErrors","allValid","keyPaths","every","kp","lookup","checkTypeMatch","resolved","lookupErrors","errors","push","length","keyType","Type","error","valid","validationErrors","verified","JSON","stringify","map","f","toString","join","isSumType","types","keys","t","helpMsg","sealValid","type_key_paths","all_key_paths","errorKeys","tkp","k","container","containerValid","containerErrors","membersValid","member","check","obj","keyPath","canBeNone","split","pathComplete","nextKey","shift","typeA","typeB","startsWith","console","option","sub","defSub","native","newType","def","defEnum","guardRedefinition","values","valueSet","exists","o","isTypeSpec","recurseObject","keyPathSet","lastLevel","levelKeys","getOwnPropertyNames","forEach","v","add","Array","isArray","warn","item","index","defOption","isUnset","maybe","defCollection","set","defTuple","pattern","specObj","key","mods","defineProperty","typeSet","cache","defOr","some","guard","originalName","mapBuiltins","constructor","defineSpecials","Function","isInteger","iterator","oName","prototype","call","replace","endsWith","for","TKey","THandlers","eventNames","handlerFuncs","validNames","validFuncs","func","TFuncArray","TEmptyArray","TMarkupObject","code","nodes","externals","TMarkupAttrObject","str","TBrutalLikeObject","to","update","oldVals","TBrutalObject","TBrutalArray","TSBrutalObject","handlers","TSBrutalArray","BS","SSR","Types","skip","markup","attrskip","attrmarkup","NULLFUNC","KEYMATCH","ATTRMATCH","KEYLEN","XSS","OBJ","KEY","UNSET","INSERT","NOTFOUND","loc","MOVE","frag","elem","appendChild","parentNode","insertBefore","nextSibling","replaceChild","firstChild","innerHTML","onerror","log","message","stack","isKey","isHandlers","d","R","u","X","x","p","exoteric","useCache","instanceKey","cacheKey","retVal","guardAndTransformVal","find","isCached","cached","firstCall","from","vmap","V","replaceValWithKeyAndOmitInstanceKey","toDOM","walker","document","createTreeWalker","NodeFilter","SHOW_ALL","makeUpdaters","nextNode","assign","childNodes","instances","location","options","position","toLocaleLowerCase","createDocumentFragment","n","isNode","querySelector","die","node","currentNode","nodeType","ELEMENT_NODE","handleElement","COMMENT_NODE","TEXT_NODE","handleNode","result","lengths","text","nodeValue","exec","val","replacer","makeNodeUpdater","replacers","nodeState","scope","oldVal","oldNodes","lastAnchor","newVal","getType","handleMarkupInNode","handleTextInNode","state","sameOrder","reverse","placeholderNode","summonPlaceholder","dn","diffNodes","size","nodesA","nodesB","an","valIndex","vi","originalLengthBefore","slice","lengthBefore","sum","value","correction","newValue","getAttributes","attrState","lastIndex","prepareAttributeUpdater","updateName","input","oldName","makeAttributeNameUpdater","makeAttributeValueUpdater","attr","hasAttribute","removeAttribute","trim","test","assignmentIndex","indexOf","reliablySetAttribute","updateAttrWithFuncarrayValue","updateAttrWithFunctionValue","updateAttrWithHandlersValue","updateAttrWithTextValue","nodesToStr","setAttribute","formatClassListValue","getAttribute","attributes","attrs","flags","includes","O","removeEventListener","addEventListener","splice","of","entries","eventName","funcVal","zeroWidthCorrection","newAttrValue","before","after","spacer","sibling","ph","guardEmptyHandlers","padEnd","templateEl","parseFromString","head","firstElementChild","HTMLTemplateElement","content","normalize","isFunc","isObject","isBrutalArray","isFuncArray","isMarkupObject","isMarkupAttrObject","isBrutal","isForgery","os","bigNodes","cloneNode","createElement","last","next","filter","newVals","updateable","didChange","ret","oldType","msg","err","s","showNodes","info","out","nodeName","toLowerCase","children","innerText"],"mappings":"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","file":"r.js","sourceRoot":"..","sourcesContent":["// common for all r submodules\n  export const CODE              = ''+Math.random();\n\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","\n  export const BROWSER_SIDE      = (() => {try{ return self.DOMParser && true; } catch(e) { return false; }})();\n\n  const BuiltIns = [\n    Symbol, Boolean, Number, String, Object, Set, Map, WeakMap, WeakSet,\n    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,\n    Int8Array, Int16Array, Int32Array, \n    Uint8ClampedArray, \n    ...(BROWSER_SIDE ? [\n      Node,NodeList,Element,HTMLElement, Blob, ArrayBuffer,\n      FileList, Text, HTMLDocument, Document, DocumentFragment,\n      Error, File, Event, EventTarget, URL\n    /* eslint-disable no-undef */\n    ] : [ Buffer ])\n    /* eslint-enable no-undef */\n  ]\n\n  const DEBUG = false;\n  const SEALED_DEFAULT = true;\n  const isNone = instance => instance == null || instance == undefined;\n\n  const typeCache = new Map();\n\n  T.def = def;\n  T.check = check;\n  T.sub = sub;\n  T.verify = verify;\n  T.validate = validate;\n  T.partialMatch = partialMatch;\n  T.defEnum = defEnum;\n  T.defSub = defSub;\n  T.defTuple = defTuple;\n  T.defCollection = defCollection;\n  T.defOr = defOr;\n  T.option = option;\n  T.defOption = defOption;\n  T.maybe = maybe;\n  T.guard = guard;\n  T.errors = errors;\n\n  // debug\n  if ( DEBUG ) {\n    self.T = T;\n    self.typeCache = typeCache;\n  }\n\n  T[Symbol.for('jtype-system.typeCache')] = typeCache;\n\n  defineSpecials();\n  mapBuiltins();\n\n  export function T(parts, ...vals) {\n    const cooked = vals.reduce((prev,cur,i) => prev+cur+parts[i+1], parts[0]);\n    const typeName = cooked;\n    if ( !typeCache.has(typeName) ) throw new TypeError(`Cannot use type ${typeName} before it is defined.`);\n    return typeCache.get(typeName).type;\n  }\n\n  function partialMatch(type, instance) {\n    return validate(type, instance, {partial:true});\n  }\n\n  function validate(type, instance, {partial: partial = false} = {}) {\n    guardType(type);\n    guardExists(type);\n    const typeName = type.name;\n\n    const {spec,kind,help,verify,verifiers,sealed} = typeCache.get(typeName);\n\n    const specKeyPaths = spec ? allKeyPaths(spec).sort() : [];\n    const specKeyPathSet = new Set(specKeyPaths);\n\n    const bigErrors = [];\n\n    switch(kind) {\n      case \"def\": {\n        let allValid = true;\n        if ( spec ) {\n          const keyPaths = partial ? allKeyPaths(instance, specKeyPathSet) : specKeyPaths;\n          allValid = !isNone(instance) && keyPaths.every(kp => {\n            // Allow lookup errors if the type match for the key path can include None\n\n            const {resolved, errors:lookupErrors} = lookup(instance,kp,() => checkTypeMatch(lookup(spec,kp).resolved, T`None`));\n            bigErrors.push(...lookupErrors);\n\n            if ( lookupErrors.length ) return false;\n\n            const keyType = lookup(spec,kp).resolved;\n            if ( !keyType || !(keyType instanceof Type) ) {\n              bigErrors.push({\n                error: `Key path '${kp}' is not present in the spec for type '${typeName}'`\n              });\n              return false;\n            }\n\n            const {valid, errors: validationErrors} = validate(keyType, resolved);\n            bigErrors.push(...validationErrors);\n\n            return valid;\n          });\n        }\n        let verified = true;\n        if ( partial && ! spec && !!verify ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for types that` + \n            ` only use a verify function but have no spec`);\n        } else if ( verify ) {\n          try {\n            verified = verify(instance);\n            if ( ! verified ) {\n              if ( verifiers ) {\n                throw {\n                  error:`Type ${typeName} value '${JSON.stringify(instance)}' violated at least 1 verify function in:\\n${\n                    verifiers.map(f => '\\t'+(f.help||'') + ' ('+f.verify.toString()+')').join('\\n')\n                  }`\n                };\n              } else if ( type.isSumType ) {\n                throw {\n                  error: `Value '${JSON.stringify(instance)}' did not match any of: ${[...type.types.keys()].map(t => t.name)}`,\n                  verify, verifiers\n                }\n              } else {\n                let helpMsg = '';\n                if ( help ) {\n                  helpMsg = `Help: ${help}. `;\n                }\n                throw {error:`${helpMsg}Type ${typeName} Value '${JSON.stringify(instance)}' violated verify function in: ${verify.toString()}`};\n              }\n            }\n          } catch(e) {\n            bigErrors.push(e);\n            verified = false;\n          }\n        }\n        let sealValid = true;\n        if ( !!sealed && !! spec ) {\n          const type_key_paths = specKeyPaths;\n          const all_key_paths = allKeyPaths(instance, specKeyPathSet).sort();\n          sealValid  = all_key_paths.join(',') == type_key_paths.join(',');\n          if ( ! sealValid ) {\n            if ( all_key_paths.length < type_key_paths.length ) {\n              sealValid = true;\n            } else {\n              const errorKeys = [];\n              const tkp = new Set(type_key_paths); \n              for( const k of all_key_paths ) {\n                if ( ! tkp.has(k) ) {\n                  errorKeys.push({\n                    error: `Key path '${k}' is not in the spec for type ${typeName}`\n                  });\n                }\n              }\n              if ( errorKeys.length ) {\n                bigErrors.push(...errorKeys);\n              }\n            }\n          }\n        }\n        return {valid: allValid && verified && sealValid, errors: bigErrors, partial}\n      } case \"defCollection\": {\n        const {valid:containerValid, errors:containerErrors} = validate(spec.container, instance);\n        let membersValid = true;\n        let verified = true;\n\n        bigErrors.push(...containerErrors);\n        if ( partial ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for Collection types`);\n        } else {\n          if ( containerValid ) {\n             membersValid= [...instance].every(member => {\n              const {valid, errors} = validate(spec.member, member);\n              bigErrors.push(...errors);\n              return valid;\n            });\n          }\n          if ( verify ) {\n            try {\n              verified = verify(instance);\n            } catch(e) {\n              bigErrors.push(e);\n              verified = false;\n            }\n          }\n        }\n          \n        return {valid:containerValid && membersValid && verified, errors:bigErrors};\n      } default: {\n        throw new TypeError(`Checking for type kind ${kind} is not yet implemented.`);\n      }\n    }\n  }\n\n  function check(...args) {\n    return validate(...args).valid;\n  }\n\n  function lookup(obj, keyPath, canBeNone) {\n    if ( isNone(obj) ) throw new TypeError(`Lookup requires a non-unset object.`);\n\n    if ( !keyPath ) throw new TypeError(`keyPath must not be empty`);\n\n\n    const keys = keyPath.split(/\\./g);\n    const pathComplete = [];\n    const errors = [];\n\n    let resolved = obj;\n\n    while(keys.length) {\n      const nextKey = keys.shift();\n      resolved = resolved[nextKey];\n      pathComplete.push(nextKey);\n      if ( (resolved === null || resolved === undefined) ) {\n        if ( keys.length ) {\n          errors.push({\n            error: \n              `Lookup on key path '${keyPath}' failed at '` + \n              pathComplete.join('.') +\n              `' when ${resolved} was found at '${nextKey}'.` \n          });\n        } else if ( !!canBeNone && canBeNone() ) {\n          resolved = undefined;\n        } else {\n          errors.push({\n            error: \n              `Resolution on key path '${keyPath}' failed` + \n              `when ${resolved} was found at '${nextKey}' and the Type of this` +\n              `key's value cannot be None.`\n          });\n        }\n        break;\n      }\n    }\n    return {resolved,errors};\n  }\n\n  function checkTypeMatch(typeA, typeB) {\n    guardType(typeA);\n    guardExists(typeA);\n    guardType(typeB);\n    guardExists(typeB);\n\n    if ( typeA === typeB ) {\n      return true;\n    } else if ( typeA.isSumType && typeA.types.has(typeB) ) {\n      return true;\n    } else if ( typeB.isSumType && typeB.types.has(typeA) ) {\n      return true;\n    } else if ( typeA.name.startsWith('?') && typeB == T`None` ) {\n      return true;\n    } else if ( typeB.name.startsWith('?') && typeA == T`None` ) {\n      return true;\n    }\n\n    if ( typeA.name.startsWith('>') || typeB.name.startsWith('>') ) {\n      console.error(new Error(`Check type match has not been implemented for derived//sub types yet.`));\n    }\n\n    return false;\n  }\n\n  function option(type) {\n    return T`?${type.name}`;\n  }\n\n  function sub(type) {\n    return T`>${type.name}`;\n  }\n\n  function defSub(type, spec, {verify: verify = undefined, help:help = ''} = {}, name = '') {\n    guardType(type);\n    guardExists(type);\n\n    let verifiers;\n\n    if ( ! verify ) {\n      verify = () => true;\n    } \n\n    if ( type.native ) {\n      verifiers = [ {help,verify} ];\n      verify = i => i instanceof type.native;\n      const helpMsg = `Needs to be of type ${type.native.name}. ${help||''}`;\n      verifiers.push({help:helpMsg,verify});\n    }\n\n    const newType = def(`${name}>${type.name}`, spec, {verify,help, verifiers});\n    return newType;\n  }\n\n  function defEnum(name, ...values) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n    \n    const valueSet = new Set(values);\n    const verify = i => valueSet.has(i);\n    const help = `Value of Enum type ${name} must be one of ${values.join(',')}`;\n\n    return def(name, null, {verify,help});\n  }\n\n  function exists(name) {\n    return typeCache.has(name);\n  }\n\n  function guardRedefinition(name) {\n    if ( exists(name) ) throw new TypeError(`Type ${name} cannot be redefined.`);\n  }\n\n  function allKeyPaths(o, specKeyPaths) {\n    const isTypeSpec = ! specKeyPaths;\n    const keyPaths = new Set();\n    return recurseObject(o, keyPaths, '');\n\n    function recurseObject(o, keyPathSet, lastLevel = '') {\n      const levelKeys = Object.getOwnPropertyNames(o); \n      const keyPaths = levelKeys\n        .map(k => lastLevel + (lastLevel.length ? '.' : '') + k)\n      levelKeys.forEach((k,i) => {\n        const v = o[k];\n        if ( isTypeSpec ) {\n          if ( v instanceof Type ) {\n            keyPathSet.add(keyPaths[i]);\n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              DEBUG && console.warn({o,v,keyPathSet, lastLevel});\n              throw new TypeError(`We don't support Types that use Arrays as structure, just yet.`); \n            }\n          } else {\n            throw new TypeError(`Spec cannot contain leaf values that are not valid Types`);\n          }\n        } else {\n          if ( specKeyPaths.has(keyPaths[i]) ) {\n            keyPathSet.add(keyPaths[i]); \n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              v.forEach((item,index) => recurseObject(item, keyPathSet, keyPaths[i] + '.' + index));\n              //throw new TypeError(`We don't support Instances that use Arrays as structure, just yet.`); \n            }\n          } else {\n            //console.warn(\"Spec has no such key\",  keyPaths[i]);\n            keyPathSet.add(keyPaths[i]);\n          }\n        }\n      });\n      return [...keyPathSet];\n    }\n  }\n\n  function defOption(type) {\n    guardType(type);\n    const typeName = type.name;\n    return T.def(`?${typeName}`, null, {verify: i => isUnset(i) || T.check(type,i)});\n  }\n\n  function maybe(type) {\n    try {\n      return defOption(type);\n    } catch(e) {\n      // console.log(`Option Type ${type.name} already declared.`, e);\n    }\n    return T`?${type.name}`;\n  }\n\n  function verify(...args) { return check(...args); }\n\n  function defCollection(name, {container, member}, {sealed: sealed = SEALED_DEFAULT, verify: verify = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !container || !member ) throw new TypeError(`Type must be specified.`);\n    guardRedefinition(name);\n\n    const kind = 'defCollection';\n    const t = new Type(name);\n    const spec = {kind, spec: { container, member}, verify, sealed, type: t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function defTuple(name, {pattern}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !pattern ) throw new TypeError(`Type must be specified.`);\n    const kind = 'def';\n    const specObj = {};\n    pattern.forEach((type,key) => specObj[key] = type);\n    const t = new Type(name);\n    const spec = {kind, spec: specObj, type:t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function Type(name, mods = {}) {\n    if ( ! new.target ) throw new TypeError(`Type with new only.`);\n    Object.defineProperty(this,'name', {get: () => name});\n    this.typeName = name;\n\n    if ( mods.types ) {\n      const {types} = mods;\n      const typeSet = new Set(types);\n      Object.defineProperty(this,'isSumType', {get: () => true});\n      Object.defineProperty(this,'types', {get: () => typeSet});\n    }\n\n    if ( mods.native ) {\n      const {native} = mods;\n      Object.defineProperty(this,'native', {get: () => native});\n    }\n  }\n\n  Type.prototype.toString = function () {\n    return `${this.typeName} Type`;\n  };\n\n  function def(name, spec, {help:help = '', verify:verify = undefined, sealed:sealed = undefined, types:types = undefined, verifiers:verifiers = undefined, native:native = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n\n    if ( name.startsWith('?') ) {\n      if ( spec ) {\n        throw new TypeError(`Option type can not have a spec.`);\n      } \n\n      if ( ! verify(null) ) {\n        throw new TypeError(`Option type must be OK to be unset.`);\n      }\n    }\n\n    const kind = 'def';\n    if ( sealed === undefined ) {\n      sealed = true;\n    }\n    const t = new Type(name, {types, native});\n    const cache = {spec,kind,help,verify,verifiers,sealed,types,native,type:t};\n    typeCache.set(name, cache);\n    return t;\n  }\n\n  function defOr(name, ...types) {\n    return T.def(name, null, {types, verify: i => types.some(t => check(t,i))});\n  }\n\n  function guard(type, instance) {\n    guardType(type);\n    guardExists(type);\n    const {valid, errors} = validate(type, instance);\n    if ( ! valid ) throw new TypeError(`Type ${type} requested, but item is not of that type: ${errors.join(', ')}`);\n  }\n\n  function guardType(t) {\n    //console.log(t);\n    if ( !(t instanceof Type) ) throw new TypeError(`Type must be a valid Type object.`);\n  }\n\n  function guardExists(t) {\n    const name = originalName(t);\n    if ( ! exists(name) ) throw new TypeError(`Type must exist. Type ${name} has not been defined.`);\n  }\n\n  function errors(...args) {\n    return validate(...args).errors;\n  }\n\n  function mapBuiltins() {\n    BuiltIns.forEach(t => def(originalName(t), null, {native: t, verify: i => originalName(i.constructor) === originalName(t)}));  \n    BuiltIns.forEach(t => defSub(T`${originalName(t)}`));  \n  }\n\n  function defineSpecials() {\n    T.def(`Any`, null, {verify: () => true});\n    T.def(`Some`, null, {verify: i => !isUnset(i)});\n    T.def(`None`, null, {verify: i => isUnset(i)});\n    T.def(`Function`, null, {verify: i => i instanceof Function});\n    T.def(`Integer`, null, {verify: i => Number.isInteger(i)});\n    T.def(`Array`, null, {verify: i => Array.isArray(i)});\n    T.def(`Iterable`, null, {verify: i => i[Symbol.iterator] instanceof Function});\n  }\n\n  function isUnset(i) {\n    return i === null || i === undefined;\n  }\n\n  function originalName(t) {\n    if (!!t && t.name) {\n      return t.name;\n    } \n    const oName = Object.prototype.toString.call(t).replace(/\\[object |\\]/g, '');\n    if ( oName.endsWith('Constructor') ) {\n      return oName.replace(/Constructor$/,'');\n    }\n    return oName;\n  }\n\n","// types\n  import {T} from './t.js';\n  import {CODE} from './common.js';\n\n  // T\n\n    export default T;\n\n  // Both SSR and Browser\n\n    export const TKey = T.def('Key', {\n      key: T.defOr('ValidKey', T`String`, T`Number`)\n    });\n\n    export const THandlers = T.def('Handlers', null, {verify: i => {\n      const validObject = T.check(T`Object`, i);\n\n      if ( ! validObject ) return false;\n\n      const eventNames = Object.keys(i);\n      const handlerFuncs = Object.values(i);\n      const validNames = eventNames.every(name => T.check(T`String`, name));\n      const validFuncs = handlerFuncs.every(func => T.check(T`Function`, func));\n      const valid = validNames && validFuncs;\n\n      return valid;\n    }});\n\n    export const TFuncArray = T.defCollection('FuncArray', {\n      container: T`Array`,\n      member: T`Function`\n    });\n\n    export const TEmptyArray = T.def('EmptyArray', null, {verify: i => Array.isArray(i) && i.length == 0});\n\n    export const TMarkupObject = T.def('MarkupObject', {\n      type: T`String`,\n      code: T`String`,\n      nodes: T`Array`,\n      externals: T`Array`,\n    }, {verify: v => v.type == 'MarkupObject' && v.code == CODE});\n\n    export const TMarkupAttrObject = T.def('MarkupAttrObject', {\n      type: T`String`,\n      code: T`String`,\n      str: T`String`\n    }, {verify: v => v.type == 'MarkupAttrObject' && v.code == CODE});\n\n  // Browser side\n\n    export const TBrutalLikeObject = T.def('BrutalLikeObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`,\n      oldVals: T`Array`\n    });\n\n    export const TBrutalObject = T.def('BrutalObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`,\n      oldVals: T`Array`\n    }, {verify: v => verify(v)});\n\n    export const TBrutalArray = T.defCollection('BrutalArray', {\n      container: T`Array`,\n      member: T`BrutalObject`\n    });\n\n  // SSR\n\n    export const TSBrutalObject = T.def('SBrutalObject', {\n      str: T`String`,\n      handlers: THandlers\n    });\n\n    export const TSBrutalArray = T.defCollection('SBrutalArray', {\n      container: T`Array`,\n      member: T`SBrutalObject`\n    });\n\n  // export\n\n  export const BS = {TKey,THandlers,TFuncArray,TBrutalObject,TBrutalLikeObject,TBrutalArray};\n\n  export const SSR = {TKey,THandlers,TFuncArray,TSBrutalObject,TSBrutalArray};\n\n  export const Types = {BS,SSR};\n\n\n  // verify function \n    function verify(v) {\n      return CODE === v.code;\n    }\n\n","// r.js\n  // imports\n    import {CODE} from './common.js';\n    import T from './types.js';\n\n  // backwards compatible alias\n    const skip = markup;\n    const attrskip = attrmarkup;\n\n  // constants\n    const DEBUG             = false;\n    const NULLFUNC          = () => void 0;\n    /* eslint-disable no-useless-escape */\n    const KEYMATCH          = /(?:<!\\-\\-)?(key\\d+)(?:\\-\\->)?/gm;\n    /* eslint-enable no-useless-escape */\n    const ATTRMATCH         = /\\w+=/;\n    const KEYLEN            = 20;\n    const XSS               = () => `Possible XSS / object forgery attack detected. ` +\n                              `Object code could not be verified.`;\n    const OBJ               = () => `Object values not allowed here.`;\n    const KEY               = v => `'key' property must be a string. Was: ${v.key}`;\n    const UNSET             = () => `Unset values not allowed here.`;\n    const INSERT            = () => `Error inserting template into DOM. ` +\n      `Position must be one of: ` +\n      `replace, beforebegin, afterbegin, beforeend, innerhtml, afterend`;\n    const NOTFOUND          = loc => `Error inserting template into DOM. ` +\n      `Location ${loc} was not found in the document.`;\n    const MOVE              = new class {\n      beforeend   (frag,elem) { elem.appendChild(frag) }\n      beforebegin (frag,elem) { elem.parentNode.insertBefore(frag,elem) }\n      afterend    (frag,elem) { elem.parentNode.insertBefore(frag,elem.nextSibling) }\n      replace     (frag,elem) { elem.parentNode.replaceChild(frag,elem) }\n      afterbegin  (frag,elem) { elem.insertBefore(frag,elem.firstChild) }\n      innerhtml   (frag,elem) { elem.innerHTML = ''; elem.appendChild(frag) }\n    };\n\n  // logging\n    self.onerror = (...v) => (console.log(v, v[0]+'', v[4] && v[4].message, v[4] && v[4].stack), true);\n\n  // type functions\n    const isKey             = v => T.check(T`Key`, v); \n    const isHandlers        = v => T.check(T`Handlers`, v);\n\n  // cache \n    const cache = {};\n    // deux\n    export const d = R;\n    export const e = d;\n    export const u = X;\n    export const x = u;\n\n  // main exports \n    Object.assign(R,{s,attrskip,skip,attrmarkup,markup,guardEmptyHandlers,die});\n\n    if ( DEBUG ) {\n      Object.assign(self, {d,u,T}); \n    }\n\n    export function R(p,...v) {\n      return exoteric(p,v);\n    }\n\n    export function X(p,...v) {\n      return exoteric(p,v,{useCache:false});\n    }\n\n  // main function (TODO: should we refactor?)\n    function exoteric(p,v,{useCache:useCache=true}={}) {\n      const retVal = {};\n      let instanceKey, cacheKey;\n\n      v = v.map(guardAndTransformVal);\n\n      if ( useCache ) {\n        ({key:instanceKey} = (v.find(isKey) || {}));\n        cacheKey = p.join('<link rel=join>');\n        const {cached,firstCall} = isCached(cacheKey,v,instanceKey);\n       \n        if ( ! firstCall ) {\n          cached.update(v);\n          return cached;\n        } else {\n          retVal.oldVals = Array.from(v);\n        }\n      } else {\n        retVal.oldVals = Array.from(v);\n      }\n      \n      // compile the template into an updater\n\n      p = [...p]; \n      const vmap = {};\n      const V = v.map(replaceValWithKeyAndOmitInstanceKey(vmap));\n      const externals = [];\n      let str = '';\n\n      while( p.length > 1 ) str += p.shift() + V.shift();\n      str += p.shift();\n\n      const frag = toDOM(str);\n      const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ALL);\n\n      do {\n        makeUpdaters({walker,vmap,externals});\n      } while(walker.nextNode())\n\n      Object.assign(retVal, {\n        externals,\n        v:Object.values(vmap),\n        to,\n        update,\n        code:CODE,\n        nodes:[...frag.childNodes]\n      });\n\n      if ( useCache ) {\n        if ( instanceKey ) {\n          cache[cacheKey].instances[instanceKey] = retVal;\n        } else {\n          cache[cacheKey] = retVal;\n        }\n      }\n\n      return retVal;\n    }\n\n  // to function\n    function to(location, options) {\n      const position = (options || 'replace').toLocaleLowerCase();\n      const frag = document.createDocumentFragment();\n      this.nodes.forEach(n => frag.appendChild(n));\n      const isNode = T.check(T`>Node`, location);\n      const elem = isNode ? location : document.querySelector(location);\n      try {\n        MOVE[position](frag,elem);\n      } catch(e) {\n        DEBUG && console.log({location,options,e,elem,isNode});\n        DEBUG && console.warn(e);\n        switch(e.constructor && e.constructor.name) {\n          case \"DOMException\":      die({error: INSERT()},e);             break;\n          case \"TypeError\":         die({error: NOTFOUND(location)},e);   break; \n          default:                  throw e;\n        }\n      }\n      while(this.externals.length) {\n        this.externals.shift()();\n      }\n    }\n\n  // update functions\n    function makeUpdaters({walker,vmap,externals}) {\n      const node = walker.currentNode;\n      switch( node.nodeType ) {\n        case Node.ELEMENT_NODE:\n          handleElement({node,vmap,externals}); break;\n        case Node.COMMENT_NODE:\n        case Node.TEXT_NODE:\n          handleNode({node,vmap,externals}); break;\n      }\n    }\n\n    function handleNode({node,vmap,externals}) {\n      const lengths = [];\n      const text = node.nodeValue; \n      let result = KEYMATCH.exec(text);\n      while ( result ) {\n        const {index} = result;\n        const key = result[1];\n        const val = vmap[key];\n        const replacer = makeNodeUpdater({node,index,lengths,val});\n        externals.push(() => replacer(val.val));\n        val.replacers.push( replacer );\n        result = KEYMATCH.exec(text);\n      }\n    }\n\n    // node functions\n      function makeNodeUpdater(nodeState) {\n        const {node} = nodeState;\n        const scope = Object.assign({}, nodeState, {\n          oldVal: {length: KEYLEN},\n          oldNodes: [node],\n          lastAnchor: node,\n        });\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"markupobject\": \n            case \"brutalobject\":\n              handleMarkupInNode(newVal, scope); break;\n            default:\n              handleTextInNode(newVal, scope); break;\n          }\n        };\n      }\n\n      function handleMarkupInNode(newVal, state) {\n        let {oldNodes,lastAnchor} = state;\n        if ( newVal.nodes.length ) {\n          if ( sameOrder(oldNodes,newVal.nodes) ) {\n            // do nothing\n          } else {\n            Array.from(newVal.nodes).reverse().forEach(n => {\n              lastAnchor.parentNode.insertBefore(n,lastAnchor.nextSibling);\n              state.lastAnchor = lastAnchor.nextSibling;\n            });\n            state.lastAnchor = newVal.nodes[0];\n          }\n        } else {\n          const placeholderNode = summonPlaceholder(lastAnchor);\n          lastAnchor.parentNode.insertBefore(placeholderNode,lastAnchor.nextSibling);\n          state.lastAnchor = placeholderNode;\n        }\n        // MARK: Unbond event might be relevant here.\n        const dn = diffNodes(oldNodes,newVal.nodes);\n        if ( dn.size ) {\n          const f = document.createDocumentFragment();\n          dn.forEach(n => f.appendChild(n));\n        }\n        state.oldNodes = newVal.nodes || [lastAnchor];\n        while ( newVal.externals.length ) {\n          const func = newVal.externals.shift();\n          func();\n        } \n      }\n\n      function sameOrder(nodesA, nodesB) {\n        if ( nodesA.length != nodesB.length ) return false;\n\n        return Array.from(nodesA).every((an,i) => an == nodesB[i]);\n      }\n\n      function handleTextInNode(newVal, state) {\n        let {oldVal, index, val, lengths, node} = state;\n\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n        const value = node.nodeValue;\n\n        lengths[valIndex] = newVal.length;\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = value.slice(0,index+correction);\n        const after = value.slice(index+correction+oldVal.length);\n\n        const newValue = before + newVal + after;\n\n        node.nodeValue = newValue;\n\n        state.oldVal = newVal;\n      }\n\n    // element attribute functions\n      function handleElement({node,vmap,externals}) {\n        getAttributes(node).forEach(({name,value} = {}) => {\n          const attrState = {node, vmap, externals, name, lengths: []};\n\n          KEYMATCH.lastIndex = 0;\n          let result = KEYMATCH.exec(name);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:true});\n            result = KEYMATCH.exec(name);\n          }\n\n          KEYMATCH.lastIndex = 0;\n          result = KEYMATCH.exec(value);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:false});\n            result = KEYMATCH.exec(value);\n          }\n        });\n      }\n\n      function prepareAttributeUpdater(result, attrState, {updateName}) {\n        const {index, input} = result;\n        const scope = Object.assign({}, attrState, {\n          index, input, updateName, \n          val: attrState.vmap[result[1]],\n          oldVal: {length: KEYLEN},\n          oldName: attrState.name,\n        });\n\n        let replacer;\n        if ( updateName ) {\n          replacer = makeAttributeNameUpdater(scope);\n        } else {\n          replacer = makeAttributeValueUpdater(scope);\n        }\n\n        scope.externals.push(() => replacer(scope.val.val));\n        scope.val.replacers.push( replacer );\n      }\n\n      // FIXME: needs to support multiple replacements just like value\n      // QUESTION: why is the variable oldName so required here, why can't we call it oldVal?\n      // if we do it breaks, WHY?\n      function makeAttributeNameUpdater(scope) {\n        let {oldName,node,val} = scope;\n        return (newVal) => {\n          if ( oldName == newVal ) return;\n          val.val = newVal;\n          const attr = node.hasAttribute(oldName) ? oldName : ''\n          if ( attr !== newVal ) {\n            if ( attr ) {\n              node.removeAttribute(oldName);\n              node[oldName] = undefined;\n            }\n            if ( newVal ) {\n              newVal = newVal.trim();\n\n              let name = newVal, value = undefined;\n\n              if( ATTRMATCH.test(newVal) ) {\n                const assignmentIndex = newVal.indexOf('='); \n                ([name,value] = [newVal.slice(0,assignmentIndex), newVal.slice(assignmentIndex+1)]);\n              }\n\n              reliablySetAttribute(node, name, value);\n            }\n            oldName = newVal;\n          }\n        };\n      }\n\n      function makeAttributeValueUpdater(scope) {\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"funcarray\":       updateAttrWithFuncarrayValue(newVal, scope); break;\n            case \"function\":        updateAttrWithFunctionValue(newVal, scope); break;\n            case \"handlers\":        updateAttrWithHandlersValue(newVal, scope); break;\n            case \"markupobject\":     \n            case \"brutalobject\": \n              newVal = nodesToStr(newVal.nodes); \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-disable no-fallthrough */\n            case \"markupattrobject\":  // deliberate fall through\n              newVal = newVal.str;\n            default:                \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-enable no-fallthrough */\n          }\n        };\n      }\n\n  // helpers\n    function getAttributes(node) {\n      if ( ! node.hasAttribute ) return [];\n\n      // for parity with classList.add (which trims whitespace)\n        // otherwise once the classList manipulation happens\n        // our indexes for replacement will be off\n      if ( node.hasAttribute('class') ) {\n        node.setAttribute('class', formatClassListValue(node.getAttribute('class')));\n      }\n      if ( !! node.attributes && Number.isInteger(node.attributes.length) ) return Array.from(node.attributes);\n      const attrs = [];\n      for ( const name of node ) {\n        if ( node.hasAttribute(name) ) {\n          attrs.push({name, value:node.getAttribute(name)});\n        }\n      }\n      return attrs;\n    }\n\n    function updateAttrWithFunctionValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          node.removeEventListener(name, oldVal, flags);\n        }\n        node.addEventListener(name, newVal, flags); \n      } else {\n        if ( oldVal ) {\n          const index = externals.indexOf(oldVal);\n          if ( index >= 0 ) {\n            externals.splice(index,1);\n          }\n        }\n        externals.push(() => newVal(node)); \n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithFuncarrayValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( oldVal && ! Array.isArray(oldVal) ) {\n        oldVal = [oldVal]; \n      }\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          oldVal.forEach(of => node.removeEventListener(name, of, flags));\n        }\n        newVal.forEach(f => node.addEventListener(name, f, flags));\n      } else {\n        if ( oldVal ) {\n          oldVal.forEach(of => {\n            const index = externals.indexOf(of);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          });\n        }\n        newVal.forEach(f => externals.push(() => f(node)));\n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithHandlersValue(newVal, scope) {\n      let {oldVal,node,externals,} = scope;\n      if ( !!oldVal && T.check(T`Handlers`, oldVal) ) {\n        Object.entries(oldVal).forEach(([eventName,funcVal]) => {\n          if ( eventName !== 'bond' ) {\n            let flags = {};\n            if ( eventName.includes(':') ) {\n              ([eventName, ...flags] = eventName.split(':'));\n              flags = flags.reduce((O,f) => {\n                O[f] = true;\n                return O;\n              }, {});\n            }\n            console.log(eventName, funcVal, flags);\n            node.removeEventListener(eventName, funcVal, flags); \n          } else {\n            const index = externals.indexOf(funcVal);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          }\n        });\n      }\n      Object.entries(newVal).forEach(([eventName,funcVal]) => {\n        if ( eventName !== 'bond' ) {\n          let flags = {};\n          if ( eventName.includes(':') ) {\n            ([eventName, ...flags] = eventName.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          node.addEventListener(eventName, funcVal, flags); \n        } else {\n          externals.push(() => funcVal(node)); \n        }\n      });\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithTextValue(newVal, scope) {\n      let {oldVal,node,index,name,val,lengths} = scope;\n      let zeroWidthCorrection = 0;\n      const valIndex = val.vi;\n      const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        \n      // we need to trim newVal to have parity with classlist add\n        // the reason we have zeroWidthCorrection = -1\n        // is because the classList is a set of non-zero width tokens\n        // separated by spaces\n        // when we have a zero width token, we have two adjacent spaces\n        // which, by virtue of our other requirement, gets replaced by a single space\n        // effectively elliding out our replacement location\n        // in order to keep our replacement location in tact\n        // we need to compensate for the loss of a token slot (effectively a token + a space)\n        // and having a -1 correction effectively does this.\n      if ( name == \"class\" ) {\n        newVal = newVal.trim();\n        if ( newVal.length == 0 ) {\n          zeroWidthCorrection = -1;\n        }\n        scope.val.val = newVal;\n      }\n      lengths[valIndex] = newVal.length + zeroWidthCorrection;\n      let attr = node.getAttribute(name);\n\n      const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n\n      const correction = lengthBefore-originalLengthBefore;\n      const before = attr.slice(0,index+correction);\n      const after = attr.slice(index+correction+oldVal.length);\n\n      let newAttrValue;\n      \n      if ( name == \"class\" ) {\n        const spacer = oldVal.length == 0 ? ' ' : '';\n        newAttrValue = before + spacer + newVal + spacer + after;\n      } else {\n        newAttrValue = before + newVal + after;\n      }\n\n      DEBUG && console.log(JSON.stringify({\n        newVal,\n        valIndex,\n        lengths,\n        attr,\n        lengthBefore,\n        originalLengthBefore,\n        correction,\n        before,\n        after,\n        newAttrValue\n      }, null, 2));\n\n      reliablySetAttribute(node, name, newAttrValue);\n\n      scope.oldVal = newVal;\n    }\n\n    function reliablySetAttribute(node, name, value ) {\n      if (  name == \"class\" ) {\n        value = formatClassListValue(value);\n      }\n\n      try {\n        node.setAttribute(name,value);\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n\n      try {\n        node[name] = value == undefined ? true : value;\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n    }\n\n    function getType(val) {\n      const type = T.check(T`Function`, val) ? 'function' :\n        T.check(T`Handlers`, val) ? 'handlers' : \n        T.check(T`BrutalObject`, val) ? 'brutalobject' : \n        T.check(T`MarkupObject`, val) ? 'markupobject' :\n        T.check(T`MarkupAttrObject`, val) ? 'markupattrobject' :\n        T.check(T`BrutalArray`, val) ? 'brutalarray' : \n        T.check(T`FuncArray`, val) ? 'funcarray' : \n        'default'\n      ;\n      return type;\n    }\n\n    function summonPlaceholder(sibling) {\n      let ph = [...sibling.parentNode.childNodes].find(\n        node => node.nodeType == Node.COMMENT_NODE && node.nodeValue == 'brutal-placeholder' );\n      if ( ! ph ) {\n        ph = toDOM(`<!--brutal-placeholder-->`).firstChild;\n      }\n      return ph;\n    }\n\n    // cache helpers\n      // FIXME: function needs refactor\n      function isCached(cacheKey,v,instanceKey) {\n        let firstCall;\n        let cached = cache[cacheKey];\n        if ( cached == undefined ) {\n          cached = cache[cacheKey] = {};\n          if ( instanceKey ) {\n            cached.instances = {};\n            cached = cached.instances[instanceKey] = {};\n          }\n          firstCall = true;\n        } else {\n          if ( instanceKey ) {\n            if ( ! cached.instances ) {\n              cached.instances = {};\n              firstCall = true;\n            } else {\n              cached = cached.instances[instanceKey];\n              if ( ! cached ) {\n                firstCall = true;\n              } else {\n                firstCall = false;\n              }\n            }\n          } else {\n            firstCall = false;\n          }\n        }\n        return {cached,firstCall};\n      }\n\n    // Markup helpers\n      // Returns an object that Brutal treats as markup,\n      // even tho it is NOT a Brutal Object (defined with R/X/$)\n      // And even tho it is in the location of a template value replacement\n      // Which would normally be the treated as String\n      function markup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        const frag = toDOM(str);\n        const retVal = {\n          type: 'MarkupObject',\n          code:CODE,\n          nodes:[...frag.childNodes],\n          externals: []\n        };\n        return retVal;\n      }\n\n      // Returns an object that Brutal treats, again, as markup\n      // But this time markup that is OKAY to have within a quoted attribute\n      function attrmarkup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        str = str.replace(/\"/g,'&quot;');\n        const retVal = {\n          type: 'MarkupAttrObject',\n          code: CODE,\n          str\n        };\n        return retVal;\n      }\n\n      function guardEmptyHandlers(val) {\n        if ( Array.isArray(val) ) {\n          if ( val.length == 0 ) {\n            return [NULLFUNC]\n          } \n          return val;\n        } else {\n          if ( T.check(T`None`, val) ) {\n            return NULLFUNC;\n          }\n        }\n      }\n\n    // other helpers\n      function formatClassListValue(value) {\n        value = value.trim();\n        value = value.replace(/\\s+/g, ' ');\n        return value;\n      }\n\n      function replaceValWithKeyAndOmitInstanceKey(vmap) {\n        return (val,vi) => {\n          // omit instance key\n          if ( T.check(T`Key`, val) ) {\n            return '';\n          }\n          const key = ('key'+Math.random()).replace('.','').padEnd(KEYLEN,'0').slice(0,KEYLEN);\n          let k = key;\n          if ( T.check(T`BrutalObject`, val) || T.check(T`MarkupObject`, val) ) {\n            k = `<!--${k}-->`;\n          }\n          vmap[key.trim()] = {vi,val,replacers:[]};\n          return k;\n        };\n      }\n\n      function toDOM(str) {\n        const templateEl = (new DOMParser).parseFromString(\n          `<template>${str}</template>`,\"text/html\"\n        ).head.firstElementChild;\n        let f;\n        if ( templateEl instanceof HTMLTemplateElement ) { \n          f = templateEl.content;\n          f.normalize();\n          return f;\n        } else {\n          throw new TypeError(`Could not find template element after parsing string to DOM:\\n=START=\\n${str}\\n=END=`);\n        }\n      }\n\n      function guardAndTransformVal(v) {\n        const isFunc          = T.check(T`Function`, v);\n        const isUnset         = T.check(T`None`, v);\n        const isObject        = T.check(T`Object`, v);\n        const isBrutalArray   = T.check(T`BrutalArray`, v);\n        const isFuncArray     = T.check(T`FuncArray`, v);\n        const isMarkupObject    = T.check(T`MarkupObject`, v);\n        const isMarkupAttrObject= T.check(T`MarkupAttrObject`, v);\n        const isBrutal        = T.check(T`BrutalObject`, v);\n        const isForgery       = T.check(T`BrutalLikeObject`, v)  && !isBrutal; \n\n        if ( isFunc )             return v;\n        if ( isBrutal )           return v;\n        if ( isKey(v) )           return v;\n        if ( isHandlers(v) )      return v;\n        if ( isBrutalArray )      return join(v); \n        if ( isFuncArray )        return v;\n        if ( isMarkupObject )     return v;\n        if ( isMarkupAttrObject)  return v;\n\n        if ( isUnset )            die({error: UNSET()});\n        if ( isForgery )          die({error: XSS()});\n\n        if ( isObject )       {\n          if ( Object.keys(v).join(',') === \"key\" ) {\n            die({error: KEY(v)});    \n          } else die({error: OBJ()});\n        }\n\n        return v+'';\n      }\n\n      function join(os) {\n        const externals = [];\n        const bigNodes = [];\n        const v = [];\n        const oldVals = [];\n        os.forEach(o => {\n          //v.push(...o.v); \n          //oldVals.push(...o.oldVals);\n          externals.push(...o.externals);\n          bigNodes.push(...o.nodes);\n        });\n        DEBUG && console.log({oldVals,v});\n        const retVal = {v,code:CODE,oldVals,nodes:bigNodes,to,update,externals};\n        return retVal;\n      }\n\n      function nodesToStr(nodes) {\n        const frag = document.createDocumentFragment();\n        nodes.forEach(n => frag.appendChild(n.cloneNode(true)));\n        const container = document.createElement('body');\n        container.appendChild(frag);\n        return container.innerHTML;\n      }\n\n      function diffNodes(last,next) {\n        last = new Set(last);\n        next = new Set(next);\n        return new Set([...last].filter(n => !next.has(n)));\n      }\n\n      function update(newVals) {\n        const updateable = this.v.filter(({vi}) => didChange(newVals[vi], this.oldVals[vi]));\n        DEBUG && console.log({updateable, oldVals:this.oldVals, newVals});\n        updateable.forEach(({vi,replacers}) => replacers.forEach(f => f(newVals[vi])));\n        this.oldVals = Array.from(newVals);\n      }\n\n      function didChange(oldVal, newVal) {\n        DEBUG && console.log({oldVal,newVal});\n        const [oldType, newType] = [oldVal, newVal].map(getType); \n        let ret;\n        if ( oldType != newType ) {\n          ret =  true;\n        } else {\n          switch(oldType) {\n            case \"brutalobject\":\n              // the brutal object is returned by a view function\n              // which has already called its updaters and checked its slot values\n              // to determine and show changes\n              // except in the case of a list of nodes\n              ret = true;\n              break;\n            /* eslint-disable no-fallthrough */\n            case \"funcarray\":\n            case \"function\":\n              // hard to equate even if same str value as scope could be diff\n              ret = true;\n              break;\n            case \"brutalarray\":\n              // need to do array dif so don't do here\n              ret = true;\n              break;\n            case \"markupattrobject\":\n            case \"markupobject\":\n              // need to check multiple things\n              ret = true;\n              break;\n            default:\n              ret = JSON.stringify(oldVal) !== JSON.stringify(newVal);\n              break;\n            /* eslint-enable no-fallthrough */\n          }\n        }\n\n        DEBUG && console.log({ret});\n        return ret;\n      }\n\n  // reporting and error helpers \n    function die(msg,err) {\n      if (DEBUG && err) console.warn(err);\n      msg.stack = ((DEBUG && err) || new Error()).stack.split(/\\s*\\n\\s*/g);\n      throw JSON.stringify(msg,null,2);\n    }\n\n    function s(msg) {\n      if ( DEBUG ) {\n        console.log(JSON.stringify(msg,showNodes,2));\n        console.info('.');\n      }\n    }\n\n    function showNodes(k,v) {\n      let out = v;\n      if ( T.check(T`>Node`, v) ) {\n        out = `<${v.nodeName.toLowerCase()} ${\n          !v.attributes ? '' : [...v.attributes].map(({name,value}) => `${name}='${value}'`).join(' ')}>${\n          v.nodeValue || (v.children && v.children.length <= 1 ? v.innerText : '')}`;\n      } else if ( typeof v === \"function\" ) {\n        return `${v.name || 'anon'}() { ... }`\n      }\n      return out;\n    }\n"]}