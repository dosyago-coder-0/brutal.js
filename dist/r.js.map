{"version":3,"sources":["common.js","t.js","types.js","r.js"],"names":["CODE","Math","random","BuiltIns","Symbol","Boolean","Number","String","Object","Set","Map","WeakMap","WeakSet","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8ClampedArray","Node","NodeList","Element","HTMLElement","Blob","ArrayBuffer","FileList","Text","HTMLDocument","Document","DocumentFragment","Error","File","Event","EventTarget","URL","DEBUG","SEALED_DEFAULT","isNone","instance","undefined","typeCache","T","parts","vals","cooked","typeName","reduce","prev","cur","i","has","TypeError","get","type","partialMatch","validate","partial","guardType","guardExists","name","spec","kind","help","verify","verifiers","sealed","specKeyPaths","allKeyPaths","sort","specKeyPathSet","bigErrors","allValid","keyPaths","every","kp","lookup","checkTypeMatch","resolved","lookupErrors","errors","push","length","keyType","Type","error","valid","validationErrors","verified","JSON","stringify","map","f","toString","join","isSumType","types","keys","t","helpMsg","e","sealValid","type_key_paths","all_key_paths","errorKeys","tkp","k","container","containerValid","containerErrors","membersValid","member","check","obj","keyPath","canBeNone","split","pathComplete","nextKey","shift","typeA","typeB","startsWith","console","option","sub","defSub","native","newType","def","defEnum","guardRedefinition","values","valueSet","exists","o","isTypeSpec","recurseObject","keyPathSet","lastLevel","levelKeys","getOwnPropertyNames","forEach","v","add","Array","isArray","warn","item","index","defOption","isUnset","maybe","defCollection","set","defTuple","pattern","specObj","key","mods","defineProperty","typeSet","cache","defOr","some","guard","originalName","mapBuiltins","constructor","defineSpecials","Function","isInteger","iterator","oName","prototype","call","replace","endsWith","self","for","TKey","THandlers","eventNames","handlerFuncs","validNames","validFuncs","func","TFuncArray","TEmptyArray","TMarkupObject","code","nodes","externals","TMarkupAttrObject","str","TBrutalLikeObject","to","update","oldVals","TBrutalObject","TBrutalArray","TSBrutalObject","handlers","TSBrutalArray","BS","SSR","Types","skip","markup","attrskip","attrmarkup","NULLFUNC","KEYMATCH","ATTRMATCH","KEYLEN","XSS","OBJ","UNSET","INSERT","NOTFOUND","loc","MOVE","frag","elem","appendChild","parentNode","insertBefore","nextSibling","replaceChild","firstChild","innerHTML","onerror","log","message","stack","isKey","isHandlers","d","R","u","X","p","dumbass","useCache","instanceKey","cacheKey","retVal","guardAndTransformVal","find","isCached","cached","firstCall","from","vmap","V","replaceValWithKeyAndOmitInstanceKey","toDOM","walker","document","createTreeWalker","NodeFilter","SHOW_ALL","makeUpdaters","nextNode","assign","childNodes","instances","location","options","position","toLocaleLowerCase","createDocumentFragment","n","isNode","querySelector","die","node","currentNode","nodeType","ELEMENT_NODE","handleElement","COMMENT_NODE","TEXT_NODE","handleNode","result","lengths","text","nodeValue","exec","val","replacer","makeNodeUpdater","replacers","nodeState","scope","oldVal","oldNodes","lastAnchor","newVal","getType","handleMarkupInNode","handleTextInNode","state","reverse","placeholderNode","summonPlaceholder","dn","diffNodes","size","valIndex","vi","originalLengthBefore","slice","lengthBefore","sum","x","value","correction","newValue","getAttributes","attrState","lastIndex","prepareAttributeUpdater","updateName","input","oldName","makeAttributeNameUpdater","makeAttributeValueUpdater","attr","hasAttribute","removeAttribute","trim","test","assignmentIndex","indexOf","reliablySetAttribute","updateAttrWithFuncarrayValue","updateAttrWithFunctionValue","updateAttrWithHandlersValue","updateAttrWithTextValue","nodesToStr","setAttribute","formatClassListValue","getAttribute","attributes","attrs","flags","includes","O","removeEventListener","addEventListener","splice","of","entries","eventName","funcVal","zeroWidthCorrection","newAttrValue","before","after","spacer","sibling","ph","guardEmptyHandlers","padEnd","templateEl","DOMParser","parseFromString","head","firstElementChild","HTMLTemplateElement","content","normalize","isFunc","isObject","isBrutalArray","isFuncArray","isMarkupObject","isMarkupAttrObject","isBrutal","isForgery","os","bigNodes","cloneNode","createElement","last","next","filter","newVals","updateable","didChange","ret","oldType","msg","err","s","showNodes","info","out","nodeName","toLowerCase","children","innerText"],"mappings":"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","file":"r.js","sourceRoot":"..","sourcesContent":["// common for all r submodules\n  export const CODE              = ''+Math.random();\n\n","\n  const BuiltIns = [\n    Symbol, Boolean, Number, String, Object, Set, Map, WeakMap, WeakSet,\n    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,\n    Int8Array, Int16Array, Int32Array, \n    Uint8ClampedArray, \n    Node,NodeList,Element,HTMLElement, Blob, ArrayBuffer,\n    FileList, Text, HTMLDocument, Document, DocumentFragment,\n    Error, File, Event, EventTarget, URL\n  ]\n\n  const DEBUG = false;\n  const SEALED_DEFAULT = true;\n  const isNone = instance => instance == null || instance == undefined;\n\n  const typeCache = new Map();\n\n  T.def = def;\n  T.check = check;\n  T.sub = sub;\n  T.verify = verify;\n  T.validate = validate;\n  T.partialMatch = partialMatch;\n  T.defEnum = defEnum;\n  T.defSub = defSub;\n  T.defTuple = defTuple;\n  T.defCollection = defCollection;\n  T.defOr = defOr;\n  T.option = option;\n  T.defOption = defOption;\n  T.maybe = maybe;\n  T.guard = guard;\n  T.errors = errors;\n\n  // debug\n  if ( DEBUG ) {\n    self.T = T;\n    self.typeCache = typeCache;\n  }\n\n  T[Symbol.for('jtype-system.typeCache')] = typeCache;\n\n  defineSpecials();\n  mapBuiltins();\n\n  export function T(parts, ...vals) {\n    const cooked = vals.reduce((prev,cur,i) => prev+cur+parts[i+1], parts[0]);\n    const typeName = cooked;\n    if ( !typeCache.has(typeName) ) throw new TypeError(`Cannot use type ${typeName} before it is defined.`);\n    return typeCache.get(typeName).type;\n  }\n\n  function partialMatch(type, instance) {\n    return validate(type, instance, {partial:true});\n  }\n\n  function validate(type, instance, {partial: partial = false} = {}) {\n    guardType(type);\n    guardExists(type);\n    const typeName = type.name;\n\n    const {spec,kind,help,verify,verifiers,sealed} = typeCache.get(typeName);\n\n    const specKeyPaths = spec ? allKeyPaths(spec).sort() : [];\n    const specKeyPathSet = new Set(specKeyPaths);\n\n    const bigErrors = [];\n\n    switch(kind) {\n      case \"def\": {\n        let allValid = true;\n        if ( spec ) {\n          const keyPaths = partial ? allKeyPaths(instance, specKeyPathSet) : specKeyPaths;\n          allValid = !isNone(instance) && keyPaths.every(kp => {\n            // Allow lookup errors if the type match for the key path can include None\n\n            const {resolved, errors:lookupErrors} = lookup(instance,kp,() => checkTypeMatch(lookup(spec,kp).resolved, T`None`));\n            bigErrors.push(...lookupErrors);\n\n            if ( lookupErrors.length ) return false;\n\n            const keyType = lookup(spec,kp).resolved;\n            if ( !keyType || !(keyType instanceof Type) ) {\n              bigErrors.push({\n                error: `Key path '${kp}' is not present in the spec for type '${typeName}'`\n              });\n              return false;\n            }\n\n            const {valid, errors: validationErrors} = validate(keyType, resolved);\n            bigErrors.push(...validationErrors);\n\n            return valid;\n          });\n        }\n        let verified = true;\n        if ( partial && ! spec && !!verify ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for types that` + \n            ` only use a verify function but have no spec`);\n        } else if ( verify ) {\n          try {\n            verified = verify(instance);\n            if ( ! verified ) {\n              if ( verifiers ) {\n                throw {\n                  error:`Type ${typeName} value '${JSON.stringify(instance)}' violated at least 1 verify function in:\\n${\n                    verifiers.map(f => '\\t'+(f.help||'') + ' ('+f.verify.toString()+')').join('\\n')\n                  }`\n                };\n              } else if ( type.isSumType ) {\n                throw {\n                  error: `Value '${JSON.stringify(instance)}' did not match any of: ${[...type.types.keys()].map(t => t.name)}`,\n                  verify, verifiers\n                }\n              } else {\n                let helpMsg = '';\n                if ( help ) {\n                  helpMsg = `Help: ${help}. `;\n                }\n                throw {error:`${helpMsg}Type ${typeName} Value '${JSON.stringify(instance)}' violated verify function in: ${verify.toString()}`};\n              }\n            }\n          } catch(e) {\n            bigErrors.push(e);\n            verified = false;\n          }\n        }\n        let sealValid = true;\n        if ( !!sealed && !! spec ) {\n          const type_key_paths = specKeyPaths;\n          const all_key_paths = allKeyPaths(instance, specKeyPathSet).sort();\n          sealValid  = all_key_paths.join(',') == type_key_paths.join(',');\n          if ( ! sealValid ) {\n            if ( all_key_paths.length < type_key_paths.length ) {\n              sealValid = true;\n            } else {\n              const errorKeys = [];\n              const tkp = new Set(type_key_paths); \n              for( const k of all_key_paths ) {\n                if ( ! tkp.has(k) ) {\n                  errorKeys.push({\n                    error: `Key path '${k}' is not in the spec for type ${typeName}`\n                  });\n                }\n              }\n              if ( errorKeys.length ) {\n                bigErrors.push(...errorKeys);\n              }\n            }\n          }\n        }\n        return {valid: allValid && verified && sealValid, errors: bigErrors, partial}\n      } case \"defCollection\": {\n        const {valid:containerValid, errors:containerErrors} = validate(spec.container, instance);\n        let membersValid = true;\n        let verified = true;\n\n        bigErrors.push(...containerErrors);\n        if ( partial ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for Collection types`);\n        } else {\n          if ( containerValid ) {\n             membersValid= [...instance].every(member => {\n              const {valid, errors} = validate(spec.member, member);\n              bigErrors.push(...errors);\n              return valid;\n            });\n          }\n          if ( verify ) {\n            try {\n              verified = verify(instance);\n            } catch(e) {\n              bigErrors.push(e);\n              verified = false;\n            }\n          }\n        }\n          \n        return {valid:containerValid && membersValid && verified, errors:bigErrors};\n      } default: {\n        throw new TypeError(`Checking for type kind ${kind} is not yet implemented.`);\n      }\n    }\n  }\n\n  function check(...args) {\n    return validate(...args).valid;\n  }\n\n  function lookup(obj, keyPath, canBeNone) {\n    if ( isNone(obj) ) throw new TypeError(`Lookup requires a non-unset object.`);\n\n    if ( !keyPath ) throw new TypeError(`keyPath must not be empty`);\n\n\n    const keys = keyPath.split(/\\./g);\n    const pathComplete = [];\n    const errors = [];\n\n    let resolved = obj;\n\n    while(keys.length) {\n      const nextKey = keys.shift();\n      resolved = resolved[nextKey];\n      pathComplete.push(nextKey);\n      if ( (resolved === null || resolved === undefined) ) {\n        if ( keys.length ) {\n          errors.push({\n            error: \n              `Lookup on key path '${keyPath}' failed at '` + \n              pathComplete.join('.') +\n              `' when ${resolved} was found at '${nextKey}'.` \n          });\n        } else if ( !!canBeNone && canBeNone() ) {\n          resolved = undefined;\n        } else {\n          errors.push({\n            error: \n              `Resolution on key path '${keyPath}' failed` + \n              `when ${resolved} was found at '${nextKey}' and the Type of this` +\n              `key's value cannot be None.`\n          });\n        }\n        break;\n      }\n    }\n    return {resolved,errors};\n  }\n\n  function checkTypeMatch(typeA, typeB) {\n    guardType(typeA);\n    guardExists(typeA);\n    guardType(typeB);\n    guardExists(typeB);\n\n    if ( typeA === typeB ) {\n      return true;\n    } else if ( typeA.isSumType && typeA.types.has(typeB) ) {\n      return true;\n    } else if ( typeB.isSumType && typeB.types.has(typeA) ) {\n      return true;\n    } else if ( typeA.name.startsWith('?') && typeB == T`None` ) {\n      return true;\n    } else if ( typeB.name.startsWith('?') && typeA == T`None` ) {\n      return true;\n    }\n\n    if ( typeA.name.startsWith('>') || typeB.name.startsWith('>') ) {\n      console.error(new Error(`Check type match has not been implemented for derived//sub types yet.`));\n    }\n\n    return false;\n  }\n\n  function option(type) {\n    return T`?${type.name}`;\n  }\n\n  function sub(type) {\n    return T`>${type.name}`;\n  }\n\n  function defSub(type, spec, {verify: verify = undefined, help:help = ''} = {}, name = '') {\n    guardType(type);\n    guardExists(type);\n\n    let verifiers;\n\n    if ( ! verify ) {\n      verify = () => true;\n    } \n\n    if ( type.native ) {\n      verifiers = [ {help,verify} ];\n      verify = i => i instanceof type.native;\n      const helpMsg = `Needs to be of type ${type.native.name}. ${help||''}`;\n      verifiers.push({help:helpMsg,verify});\n    }\n\n    const newType = def(`${name}>${type.name}`, spec, {verify,help, verifiers});\n    return newType;\n  }\n\n  function defEnum(name, ...values) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n    \n    const valueSet = new Set(values);\n    const verify = i => valueSet.has(i);\n    const help = `Value of Enum type ${name} must be one of ${values.join(',')}`;\n\n    return def(name, null, {verify,help});\n  }\n\n  function exists(name) {\n    return typeCache.has(name);\n  }\n\n  function guardRedefinition(name) {\n    if ( exists(name) ) throw new TypeError(`Type ${name} cannot be redefined.`);\n  }\n\n  function allKeyPaths(o, specKeyPaths) {\n    const isTypeSpec = ! specKeyPaths;\n    const keyPaths = new Set();\n    return recurseObject(o, keyPaths, '');\n\n    function recurseObject(o, keyPathSet, lastLevel = '') {\n      const levelKeys = Object.getOwnPropertyNames(o); \n      const keyPaths = levelKeys\n        .map(k => lastLevel + (lastLevel.length ? '.' : '') + k)\n      levelKeys.forEach((k,i) => {\n        const v = o[k];\n        if ( isTypeSpec ) {\n          if ( v instanceof Type ) {\n            keyPathSet.add(keyPaths[i]);\n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              DEBUG && console.warn({o,v,keyPathSet, lastLevel});\n              throw new TypeError(`We don't support Types that use Arrays as structure, just yet.`); \n            }\n          } else {\n            throw new TypeError(`Spec cannot contain leaf values that are not valid Types`);\n          }\n        } else {\n          if ( specKeyPaths.has(keyPaths[i]) ) {\n            keyPathSet.add(keyPaths[i]); \n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              v.forEach((item,index) => recurseObject(item, keyPathSet, keyPaths[i] + '.' + index));\n              //throw new TypeError(`We don't support Instances that use Arrays as structure, just yet.`); \n            }\n          } else {\n            //console.warn(\"Spec has no such key\",  keyPaths[i]);\n            keyPathSet.add(keyPaths[i]);\n          }\n        }\n      });\n      return [...keyPathSet];\n    }\n  }\n\n  function defOption(type) {\n    guardType(type);\n    const typeName = type.name;\n    return T.def(`?${typeName}`, null, {verify: i => isUnset(i) || T.check(type,i)});\n  }\n\n  function maybe(type) {\n    try {\n      return defOption(type);\n    } catch(e) {\n      // console.log(`Option Type ${type.name} already declared.`, e);\n    }\n    return T`?${type.name}`;\n  }\n\n  function verify(...args) { return check(...args); }\n\n  function defCollection(name, {container, member}, {sealed: sealed = SEALED_DEFAULT, verify: verify = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !container || !member ) throw new TypeError(`Type must be specified.`);\n    guardRedefinition(name);\n\n    const kind = 'defCollection';\n    const t = new Type(name);\n    const spec = {kind, spec: { container, member}, verify, sealed, type: t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function defTuple(name, {pattern}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !pattern ) throw new TypeError(`Type must be specified.`);\n    const kind = 'def';\n    const specObj = {};\n    pattern.forEach((type,key) => specObj[key] = type);\n    const t = new Type(name);\n    const spec = {kind, spec: specObj, type:t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function Type(name, mods = {}) {\n    if ( ! new.target ) throw new TypeError(`Type with new only.`);\n    Object.defineProperty(this,'name', {get: () => name});\n    this.typeName = name;\n\n    if ( mods.types ) {\n      const {types} = mods;\n      const typeSet = new Set(types);\n      Object.defineProperty(this,'isSumType', {get: () => true});\n      Object.defineProperty(this,'types', {get: () => typeSet});\n    }\n\n    if ( mods.native ) {\n      const {native} = mods;\n      Object.defineProperty(this,'native', {get: () => native});\n    }\n  }\n\n  Type.prototype.toString = function () {\n    return `${this.typeName} Type`;\n  };\n\n  function def(name, spec, {help:help = '', verify:verify = undefined, sealed:sealed = undefined, types:types = undefined, verifiers:verifiers = undefined, native:native = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n\n    if ( name.startsWith('?') ) {\n      if ( spec ) {\n        throw new TypeError(`Option type can not have a spec.`);\n      } \n\n      if ( ! verify(null) ) {\n        throw new TypeError(`Option type must be OK to be unset.`);\n      }\n    }\n\n    const kind = 'def';\n    if ( sealed === undefined ) {\n      sealed = true;\n    }\n    const t = new Type(name, {types, native});\n    const cache = {spec,kind,help,verify,verifiers,sealed,types,native,type:t};\n    typeCache.set(name, cache);\n    return t;\n  }\n\n  function defOr(name, ...types) {\n    return T.def(name, null, {types, verify: i => types.some(t => check(t,i))});\n  }\n\n  function guard(type, instance) {\n    guardType(type);\n    guardExists(type);\n    const {valid, errors} = validate(type, instance);\n    if ( ! valid ) throw new TypeError(`Type ${type} requested, but item is not of that type: ${errors.join(', ')}`);\n  }\n\n  function guardType(t) {\n    //console.log(t);\n    if ( !(t instanceof Type) ) throw new TypeError(`Type must be a valid Type object.`);\n  }\n\n  function guardExists(t) {\n    const name = originalName(t);\n    if ( ! exists(name) ) throw new TypeError(`Type must exist. Type ${name} has not been defined.`);\n  }\n\n  function errors(...args) {\n    return validate(...args).errors;\n  }\n\n  function mapBuiltins() {\n    BuiltIns.forEach(t => def(originalName(t), null, {native: t, verify: i => originalName(i.constructor) === originalName(t)}));  \n    BuiltIns.forEach(t => defSub(T`${originalName(t)}`));  \n  }\n\n  function defineSpecials() {\n    T.def(`Any`, null, {verify: () => true});\n    T.def(`Some`, null, {verify: i => !isUnset(i)});\n    T.def(`None`, null, {verify: i => isUnset(i)});\n    T.def(`Function`, null, {verify: i => i instanceof Function});\n    T.def(`Integer`, null, {verify: i => Number.isInteger(i)});\n    T.def(`Array`, null, {verify: i => Array.isArray(i)});\n    T.def(`Iterable`, null, {verify: i => i[Symbol.iterator] instanceof Function});\n  }\n\n  function isUnset(i) {\n    return i === null || i === undefined;\n  }\n\n  function originalName(t) {\n    if (!!t && t.name) {\n      return t.name;\n    } \n    const oName = Object.prototype.toString.call(t).replace(/\\[object |\\]/g, '');\n    if ( oName.endsWith('Constructor') ) {\n      return oName.replace(/Constructor$/,'');\n    }\n    return oName;\n  }\n\n","// types\n  import {T} from './t.js';\n  import {CODE} from './common.js';\n\n  // T\n\n    export default T;\n\n  // Both SSR and Browser\n\n    export const TKey = T.def('Key', {\n      key: T.defOr('ValidKey', T`String`, T`Number`)\n    });\n\n    export const THandlers = T.def('Handlers', null, {verify: i => {\n      const validObject = T.check(T`Object`, i);\n\n      if ( ! validObject ) return false;\n\n      const eventNames = Object.keys(i);\n      const handlerFuncs = Object.values(i);\n      const validNames = eventNames.every(name => T.check(T`String`, name));\n      const validFuncs = handlerFuncs.every(func => T.check(T`Function`, func));\n      const valid = validNames && validFuncs;\n\n      return valid;\n    }});\n\n    export const TFuncArray = T.defCollection('FuncArray', {\n      container: T`Array`,\n      member: T`Function`\n    });\n\n    export const TEmptyArray = T.def('EmptyArray', null, {verify: i => Array.isArray(i) && i.length == 0});\n\n    export const TMarkupObject = T.def('MarkupObject', {\n      type: T`String`,\n      code: T`String`,\n      nodes: T`Array`,\n      externals: T`Array`,\n    }, {verify: v => v.type == 'MarkupObject' && v.code == CODE});\n\n    export const TMarkupAttrObject = T.def('MarkupAttrObject', {\n      type: T`String`,\n      code: T`String`,\n      str: T`String`\n    }, {verify: v => v.type == 'MarkupAttrObject' && v.code == CODE});\n\n  // Browser side\n\n    export const TBrutalLikeObject = T.def('BrutalLikeObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`,\n      oldVals: T`Array`\n    });\n\n    export const TBrutalObject = T.def('BrutalObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`,\n      oldVals: T`Array`\n    }, {verify: v => verify(v)});\n\n    export const TBrutalArray = T.defCollection('BrutalArray', {\n      container: T`Array`,\n      member: T`BrutalObject`\n    });\n\n  // SSR\n\n    export const TSBrutalObject = T.def('SBrutalObject', {\n      str: T`String`,\n      handlers: THandlers\n    });\n\n    export const TSBrutalArray = T.defCollection('SBrutalArray', {\n      container: T`Array`,\n      member: T`SBrutalObject`\n    });\n\n  // export\n\n  export const BS = {TKey,THandlers,TFuncArray,TBrutalObject,TBrutalLikeObject,TBrutalArray};\n\n  export const SSR = {TKey,THandlers,TFuncArray,TSBrutalObject,TSBrutalArray};\n\n  export const Types = {BS,SSR};\n\n\n  // verify function \n    function verify(v) {\n      return CODE === v.code;\n    }\n\n","// r.js\n  // imports\n    import {CODE} from './common.js';\n    import T from './types.js';\n\n  // backwards compatible alias\n    const skip = markup;\n    const attrskip = attrmarkup;\n\n  // constants\n    const DEBUG             = false;\n    const NULLFUNC          = () => void 0;\n    /* eslint-disable no-useless-escape */\n    const KEYMATCH          = /(?:<!\\-\\-)?(key\\d+)(?:\\-\\->)?/gm;\n    /* eslint-enable no-useless-escape */\n    const ATTRMATCH         = /\\w+=/;\n    const KEYLEN            = 20;\n    const XSS               = () => `Possible XSS / object forgery attack detected. ` +\n                              `Object code could not be verified.`;\n    const OBJ               = () => `Object values not allowed here.`;\n    const UNSET             = () => `Unset values not allowed here.`;\n    const INSERT            = () => `Error inserting template into DOM. ` +\n      `Position must be one of: ` +\n      `replace, beforebegin, afterbegin, beforeend, innerhtml, afterend`;\n    const NOTFOUND          = loc => `Error inserting template into DOM. ` +\n      `Location ${loc} was not found in the document.`;\n    const MOVE              = new class {\n      beforeend   (frag,elem) { elem.appendChild(frag) }\n      beforebegin (frag,elem) { elem.parentNode.insertBefore(frag,elem) }\n      afterend    (frag,elem) { elem.parentNode.insertBefore(frag,elem.nextSibling) }\n      replace     (frag,elem) { elem.parentNode.replaceChild(frag,elem) }\n      afterbegin  (frag,elem) { elem.insertBefore(frag,elem.firstChild) }\n      innerhtml   (frag,elem) { elem.innerHTML = ''; elem.appendChild(frag) }\n    };\n\n  // logging\n    self.onerror = (...v) => (console.log(v, v[0]+'', v[4] && v[4].message, v[4] && v[4].stack), true);\n\n  // type functions\n    const isKey             = v => T.check(T`Key`, v);\n    const isHandlers        = v => T.check(T`Handlers`, v);\n\n  // cache \n    const cache = {};\n    export const d = R;\n    export const u = X;\n\n  // main exports \n    Object.assign(R,{s,attrskip,skip,attrmarkup,markup,guardEmptyHandlers,die});\n\n    if ( DEBUG ) {\n      Object.assign(self, {d,u,T}); \n    }\n\n    export function R(p,...v) {\n      return dumbass(p,v);\n    }\n\n    export function X(p,...v) {\n      return dumbass(p,v,{useCache:false});\n    }\n\n  // main function (TODO: should we refactor?)\n    function dumbass(p,v,{useCache:useCache=true}={}) {\n      const retVal = {};\n      let instanceKey, cacheKey;\n\n      v = v.map(guardAndTransformVal);\n\n      if ( useCache ) {\n        ({key:instanceKey} = (v.find(isKey) || {}));\n        cacheKey = p.join('<link rel=join>');\n        const {cached,firstCall} = isCached(cacheKey,v,instanceKey);\n       \n        if ( ! firstCall ) {\n          cached.update(v);\n          return cached;\n        } else {\n          retVal.oldVals = Array.from(v);\n        }\n      } else {\n        retVal.oldVals = Array.from(v);\n      }\n      \n      // compile the template into an updater\n\n      p = [...p]; \n      const vmap = {};\n      const V = v.map(replaceValWithKeyAndOmitInstanceKey(vmap));\n      const externals = [];\n      let str = '';\n\n      while( p.length > 1 ) str += p.shift() + V.shift();\n      str += p.shift();\n\n      const frag = toDOM(str);\n      const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ALL);\n\n      do {\n        makeUpdaters({walker,vmap,externals});\n      } while(walker.nextNode())\n\n      Object.assign(retVal, {\n        externals,\n        v:Object.values(vmap),\n        to,\n        update,\n        code:CODE,\n        nodes:[...frag.childNodes]\n      });\n\n      if ( useCache ) {\n        if ( instanceKey ) {\n          cache[cacheKey].instances[instanceKey] = retVal;\n        } else {\n          cache[cacheKey] = retVal;\n        }\n      }\n\n      return retVal;\n    }\n\n  // to function\n    function to(location, options) {\n      const position = (options || 'replace').toLocaleLowerCase();\n      const frag = document.createDocumentFragment();\n      this.nodes.forEach(n => frag.appendChild(n));\n      const isNode = T.check(T`>Node`, location);\n      const elem = isNode ? location : document.querySelector(location);\n      try {\n        MOVE[position](frag,elem);\n      } catch(e) {\n        DEBUG && console.log({location,options,e,elem,isNode});\n        DEBUG && console.warn(e);\n        switch(e.constructor && e.constructor.name) {\n          case \"DOMException\":      die({error: INSERT()},e);             break;\n          case \"TypeError\":         die({error: NOTFOUND(location)},e);   break; \n          default:                  throw e;\n        }\n      }\n      while(this.externals.length) {\n        this.externals.shift()();\n      }\n    }\n\n  // update functions\n    function makeUpdaters({walker,vmap,externals}) {\n      const node = walker.currentNode;\n      switch( node.nodeType ) {\n        case Node.ELEMENT_NODE:\n          handleElement({node,vmap,externals}); break;\n        case Node.COMMENT_NODE:\n        case Node.TEXT_NODE:\n          handleNode({node,vmap,externals}); break;\n      }\n    }\n\n    function handleNode({node,vmap,externals}) {\n      const lengths = [];\n      const text = node.nodeValue; \n      let result = KEYMATCH.exec(text);\n      while ( result ) {\n        const {index} = result;\n        const key = result[1];\n        const val = vmap[key];\n        const replacer = makeNodeUpdater({node,index,lengths,val});\n        externals.push(() => replacer(val.val));\n        val.replacers.push( replacer );\n        result = KEYMATCH.exec(text);\n      }\n    }\n\n    // node functions\n      function makeNodeUpdater(nodeState) {\n        const {node} = nodeState;\n        const scope = Object.assign({}, nodeState, {\n          oldVal: {length: KEYLEN},\n          oldNodes: [node],\n          lastAnchor: node,\n        });\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"markupobject\": \n            case \"brutalobject\":\n              handleMarkupInNode(newVal, scope); break;\n            default:\n              handleTextInNode(newVal, scope); break;\n          }\n        };\n      }\n\n      function handleMarkupInNode(newVal, state) {\n        let {oldNodes,lastAnchor} = state;\n        if ( newVal.nodes.length ) {\n          Array.from(newVal.nodes).reverse().forEach(n => {\n            lastAnchor.parentNode.insertBefore(n,lastAnchor.nextSibling);\n            state.lastAnchor = lastAnchor.nextSibling;\n          });\n          state.lastAnchor = newVal.nodes[0];\n        } else {\n          const placeholderNode = summonPlaceholder(lastAnchor);\n          lastAnchor.parentNode.insertBefore(placeholderNode,lastAnchor.nextSibling);\n          state.lastAnchor = placeholderNode;\n        }\n        // MARK: Unbond event might be relevant here.\n        const dn = diffNodes(oldNodes,newVal.nodes);\n        if ( dn.size ) {\n          const f = document.createDocumentFragment();\n          dn.forEach(n => f.appendChild(n));\n        }\n        state.oldNodes = newVal.nodes || [lastAnchor];\n        while ( newVal.externals.length ) {\n          const func = newVal.externals.shift();\n          func();\n        } \n      }\n\n      function handleTextInNode(newVal, state) {\n        let {oldVal, index, val, lengths, node} = state;\n\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n        const value = node.nodeValue;\n\n        lengths[valIndex] = newVal.length;\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = value.slice(0,index+correction);\n        const after = value.slice(index+correction+oldVal.length);\n\n        const newValue = before + newVal + after;\n\n        node.nodeValue = newValue;\n\n        state.oldVal = newVal;\n      }\n\n    // element attribute functions\n      function handleElement({node,vmap,externals}) {\n        getAttributes(node).forEach(({name,value} = {}) => {\n          const attrState = {node, vmap, externals, name, lengths: []};\n\n          KEYMATCH.lastIndex = 0;\n          let result = KEYMATCH.exec(name);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:true});\n            result = KEYMATCH.exec(name);\n          }\n\n          KEYMATCH.lastIndex = 0;\n          result = KEYMATCH.exec(value);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:false});\n            result = KEYMATCH.exec(value);\n          }\n        });\n      }\n\n      function prepareAttributeUpdater(result, attrState, {updateName}) {\n        const {index, input} = result;\n        const scope = Object.assign({}, attrState, {\n          index, input, updateName, \n          val: attrState.vmap[result[1]],\n          oldVal: {length: KEYLEN},\n          oldName: attrState.name,\n        });\n\n        let replacer;\n        if ( updateName ) {\n          replacer = makeAttributeNameUpdater(scope);\n        } else {\n          replacer = makeAttributeValueUpdater(scope);\n        }\n\n        scope.externals.push(() => replacer(scope.val.val));\n        scope.val.replacers.push( replacer );\n      }\n\n      // FIXME: needs to support multiple replacements just like value\n      // QUESTION: why is the variable oldName so required here, why can't we call it oldVal?\n      // if we do it breaks, WHY?\n      function makeAttributeNameUpdater(scope) {\n        let {oldName,node,val} = scope;\n        return (newVal) => {\n          if ( oldName == newVal ) return;\n          val.val = newVal;\n          const attr = node.hasAttribute(oldName) ? oldName : ''\n          if ( attr !== newVal ) {\n            if ( attr ) {\n              node.removeAttribute(oldName);\n              node[oldName] = undefined;\n            }\n            if ( newVal ) {\n              newVal = newVal.trim();\n\n              let name = newVal, value = undefined;\n\n              if( ATTRMATCH.test(newVal) ) {\n                const assignmentIndex = newVal.indexOf('='); \n                ([name,value] = [newVal.slice(0,assignmentIndex), newVal.slice(assignmentIndex+1)]);\n              }\n\n              reliablySetAttribute(node, name, value);\n            }\n            oldName = newVal;\n          }\n        };\n      }\n\n      function makeAttributeValueUpdater(scope) {\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"funcarray\":       updateAttrWithFuncarrayValue(newVal, scope); break;\n            case \"function\":        updateAttrWithFunctionValue(newVal, scope); break;\n            case \"handlers\":        updateAttrWithHandlersValue(newVal, scope); break;\n            case \"markupobject\":     \n            case \"brutalobject\": \n              newVal = nodesToStr(newVal.nodes); \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-disable no-fallthrough */\n            case \"markupattrobject\":  // deliberate fall through\n              newVal = newVal.str;\n            default:                \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-enable no-fallthrough */\n          }\n        };\n      }\n\n  // helpers\n    function getAttributes(node) {\n      if ( ! node.hasAttribute ) return [];\n\n      // for parity with classList.add (which trims whitespace)\n        // otherwise once the classList manipulation happens\n        // our indexes for replacement will be off\n      if ( node.hasAttribute('class') ) {\n        node.setAttribute('class', formatClassListValue(node.getAttribute('class')));\n      }\n      if ( !! node.attributes && Number.isInteger(node.attributes.length) ) return Array.from(node.attributes);\n      const attrs = [];\n      for ( const name of node ) {\n        if ( node.hasAttribute(name) ) {\n          attrs.push({name, value:node.getAttribute(name)});\n        }\n      }\n      return attrs;\n    }\n\n    function updateAttrWithFunctionValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          node.removeEventListener(name, oldVal, flags);\n        }\n        node.addEventListener(name, newVal, flags); \n      } else {\n        if ( oldVal ) {\n          const index = externals.indexOf(oldVal);\n          if ( index >= 0 ) {\n            externals.splice(index,1);\n          }\n        }\n        externals.push(() => newVal(node)); \n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithFuncarrayValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( oldVal && ! Array.isArray(oldVal) ) {\n        oldVal = [oldVal]; \n      }\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          oldVal.forEach(of => node.removeEventListener(name, of, flags));\n        }\n        newVal.forEach(f => node.addEventListener(name, f, flags));\n      } else {\n        if ( oldVal ) {\n          oldVal.forEach(of => {\n            const index = externals.indexOf(of);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          });\n        }\n        newVal.forEach(f => externals.push(() => f(node)));\n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithHandlersValue(newVal, scope) {\n      let {oldVal,node,externals,} = scope;\n      if ( !!oldVal && T.check(T`Handlers`, oldVal) ) {\n        Object.entries(oldVal).forEach(([eventName,funcVal]) => {\n          if ( eventName !== 'bond' ) {\n            let flags = {};\n            if ( eventName.includes(':') ) {\n              ([eventName, ...flags] = eventName.split(':'));\n              flags = flags.reduce((O,f) => {\n                O[f] = true;\n                return O;\n              }, {});\n            }\n            console.log(eventName, funcVal, flags);\n            node.removeEventListener(eventName, funcVal, flags); \n          } else {\n            const index = externals.indexOf(funcVal);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          }\n        });\n      }\n      Object.entries(newVal).forEach(([eventName,funcVal]) => {\n        if ( eventName !== 'bond' ) {\n          let flags = {};\n          if ( eventName.includes(':') ) {\n            ([eventName, ...flags] = eventName.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          node.addEventListener(eventName, funcVal, flags); \n        } else {\n          externals.push(() => funcVal(node)); \n        }\n      });\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithTextValue(newVal, scope) {\n      let {oldVal,node,index,name,val,lengths} = scope;\n      let zeroWidthCorrection = 0;\n      const valIndex = val.vi;\n      const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        \n      // we need to trim newVal to have parity with classlist add\n        // the reason we have zeroWidthCorrection = -1\n        // is because the classList is a set of non-zero width tokens\n        // separated by spaces\n        // when we have a zero width token, we have two adjacent spaces\n        // which, by virtue of our other requirement, gets replaced by a single space\n        // effectively elliding out our replacement location\n        // in order to keep our replacement location in tact\n        // we need to compensate for the loss of a token slot (effectively a token + a space)\n        // and having a -1 correction effectively does this.\n      if ( name == \"class\" ) {\n        newVal = newVal.trim();\n        if ( newVal.length == 0 ) {\n          zeroWidthCorrection = -1;\n        }\n        scope.val.val = newVal;\n      }\n      lengths[valIndex] = newVal.length + zeroWidthCorrection;\n      let attr = node.getAttribute(name);\n\n      const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n\n      const correction = lengthBefore-originalLengthBefore;\n      const before = attr.slice(0,index+correction);\n      const after = attr.slice(index+correction+oldVal.length);\n\n      let newAttrValue;\n      \n      if ( name == \"class\" ) {\n        const spacer = oldVal.length == 0 ? ' ' : '';\n        newAttrValue = before + spacer + newVal + spacer + after;\n      } else {\n        newAttrValue = before + newVal + after;\n      }\n\n      DEBUG && console.log(JSON.stringify({\n        newVal,\n        valIndex,\n        lengths,\n        attr,\n        lengthBefore,\n        originalLengthBefore,\n        correction,\n        before,\n        after,\n        newAttrValue\n      }, null, 2));\n\n      reliablySetAttribute(node, name, newAttrValue);\n\n      scope.oldVal = newVal;\n    }\n\n    function reliablySetAttribute(node, name, value ) {\n      if (  name == \"class\" ) {\n        value = formatClassListValue(value);\n      }\n\n      try {\n        node.setAttribute(name,value);\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n\n      try {\n        node[name] = value == undefined ? true : value;\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n    }\n\n    function getType(val) {\n      const type = T.check(T`Function`, val) ? 'function' :\n        T.check(T`Handlers`, val) ? 'handlers' : \n        T.check(T`BrutalObject`, val) ? 'brutalobject' : \n        T.check(T`MarkupObject`, val) ? 'markupobject' :\n        T.check(T`MarkupAttrObject`, val) ? 'markupattrobject' :\n        T.check(T`BrutalArray`, val) ? 'brutalarray' : \n        T.check(T`FuncArray`, val) ? 'funcarray' : \n        'default'\n      ;\n      return type;\n    }\n\n    function summonPlaceholder(sibling) {\n      let ph = [...sibling.parentNode.childNodes].find(\n        node => node.nodeType == Node.COMMENT_NODE && node.nodeValue == 'brutal-placeholder' );\n      if ( ! ph ) {\n        ph = toDOM(`<!--brutal-placeholder-->`).firstChild;\n      }\n      return ph;\n    }\n\n    // cache helpers\n      // FIXME: function needs refactor\n      function isCached(cacheKey,v,instanceKey) {\n        let firstCall;\n        let cached = cache[cacheKey];\n        if ( cached == undefined ) {\n          cached = cache[cacheKey] = {};\n          if ( instanceKey ) {\n            cached.instances = {};\n            cached = cached.instances[instanceKey] = {};\n          }\n          firstCall = true;\n        } else {\n          if ( instanceKey ) {\n            if ( ! cached.instances ) {\n              cached.instances = {};\n              firstCall = true;\n            } else {\n              cached = cached.instances[instanceKey];\n              if ( ! cached ) {\n                firstCall = true;\n              } else {\n                firstCall = false;\n              }\n            }\n          } else {\n            firstCall = false;\n          }\n        }\n        return {cached,firstCall};\n      }\n\n    // Markup helpers\n      // Returns an object that Brutal treats as markup,\n      // even tho it is NOT a Brutal Object (defined with R/X/$)\n      // And even tho it is in the location of a template value replacement\n      // Which would normally be the treated as String\n      function markup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        const frag = toDOM(str);\n        const retVal = {\n          type: 'MarkupObject',\n          code:CODE,\n          nodes:[...frag.childNodes],\n          externals: []\n        };\n        return retVal;\n      }\n\n      // Returns an object that Brutal treats, again, as markup\n      // But this time markup that is OKAY to have within a quoted attribute\n      function attrmarkup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        str = str.replace(/\"/g,'&quot;');\n        const retVal = {\n          type: 'MarkupAttrObject',\n          code: CODE,\n          str\n        };\n        return retVal;\n      }\n\n      function guardEmptyHandlers(val) {\n        if ( Array.isArray(val) ) {\n          if ( val.length == 0 ) {\n            return [NULLFUNC]\n          } \n          return val;\n        } else {\n          if ( T.check(T`None`, val) ) {\n            return NULLFUNC;\n          }\n        }\n      }\n\n    // other helpers\n      function formatClassListValue(value) {\n        value = value.trim();\n        value = value.replace(/\\s+/g, ' ');\n        return value;\n      }\n\n      function replaceValWithKeyAndOmitInstanceKey(vmap) {\n        return (val,vi) => {\n          // omit instance key\n          if ( T.check(T`Key`, val) ) {\n            return '';\n          }\n          const key = ('key'+Math.random()).replace('.','').padEnd(KEYLEN,'0').slice(0,KEYLEN);\n          let k = key;\n          if ( T.check(T`BrutalObject`, val) || T.check(T`MarkupObject`, val) ) {\n            k = `<!--${k}-->`;\n          }\n          vmap[key.trim()] = {vi,val,replacers:[]};\n          return k;\n        };\n      }\n\n      function toDOM(str) {\n        const templateEl = (new DOMParser).parseFromString(\n          `<template>${str}</template>`,\"text/html\"\n        ).head.firstElementChild;\n        let f;\n        if ( templateEl instanceof HTMLTemplateElement ) { \n          f = templateEl.content;\n          f.normalize();\n          return f;\n        } else {\n          throw new TypeError(`Could not find template element after parsing string to DOM:\\n=START=\\n${str}\\n=END=`);\n        }\n      }\n\n      function guardAndTransformVal(v) {\n        const isFunc          = T.check(T`Function`, v);\n        const isUnset         = T.check(T`None`, v);\n        const isObject        = T.check(T`Object`, v);\n        const isBrutalArray   = T.check(T`BrutalArray`, v);\n        const isFuncArray     = T.check(T`FuncArray`, v);\n        const isMarkupObject    = T.check(T`MarkupObject`, v);\n        const isMarkupAttrObject= T.check(T`MarkupAttrObject`, v);\n        const isBrutal        = T.check(T`BrutalObject`, v);\n        const isForgery       = T.check(T`BrutalLikeObject`, v)  && !isBrutal; \n\n        if ( isFunc )         return v;\n        if ( isBrutal )       return v;\n        if ( isKey(v) )       return v;\n        if ( isHandlers(v) )  return v;\n        if ( isBrutalArray )  return join(v); \n        if ( isFuncArray )    return v;\n        if ( isMarkupObject )   return v;\n        if ( isMarkupAttrObject)return v;\n        if ( isUnset )        die({error: UNSET()});\n        if ( isForgery )      die({error: XSS()});\n        if ( isObject )       die({error: OBJ()});\n\n        return v+'';\n      }\n\n      function join(os) {\n        const externals = [];\n        const bigNodes = [];\n        const v = [];\n        const oldVals = [];\n        os.forEach(o => {\n          //v.push(...o.v); \n          //oldVals.push(...o.oldVals);\n          externals.push(...o.externals);\n          bigNodes.push(...o.nodes);\n        });\n        DEBUG && console.log({oldVals,v});\n        const retVal = {v,code:CODE,oldVals,nodes:bigNodes,to,update,externals};\n        return retVal;\n      }\n\n      function nodesToStr(nodes) {\n        const frag = document.createDocumentFragment();\n        nodes.forEach(n => frag.appendChild(n.cloneNode(true)));\n        const container = document.createElement('body');\n        container.appendChild(frag);\n        return container.innerHTML;\n      }\n\n      function diffNodes(last,next) {\n        last = new Set(last);\n        next = new Set(next);\n        return new Set([...last].filter(n => !next.has(n)));\n      }\n\n      function update(newVals) {\n        const updateable = this.v.filter(({vi}) => didChange(newVals[vi], this.oldVals[vi]));\n        DEBUG && console.log({updateable, oldVals:this.oldVals, newVals});\n        updateable.forEach(({vi,replacers}) => replacers.forEach(f => f(newVals[vi])));\n        this.oldVals = Array.from(newVals);\n      }\n\n      function didChange(oldVal, newVal) {\n        DEBUG && console.log({oldVal,newVal});\n        const [oldType, newType] = [oldVal, newVal].map(getType); \n        let ret;\n        if ( oldType != newType ) {\n          ret =  true;\n        } else {\n          switch(oldType) {\n            case \"brutalobject\":\n              // the brutal object is returned by a view function\n              // which has already called its updaters and checked its slot values\n              // to determine and show changes\n              // except in the case of a list of nodes\n              ret = true;\n              break;\n            /* eslint-disable no-fallthrough */\n            case \"funcarray\":\n            case \"function\":\n              // hard to equate even if same str value as scope could be diff\n              ret = true;\n              break;\n            case \"brutalarray\":\n              // need to do array dif so don't do here\n              ret = true;\n              break;\n            case \"markupattrobject\":\n            case \"markupobject\":\n              // need to check multiple things\n              ret = true;\n              break;\n            default:\n              ret = JSON.stringify(oldVal) !== JSON.stringify(newVal);\n              break;\n            /* eslint-enable no-fallthrough */\n          }\n        }\n\n        DEBUG && console.log({ret});\n        return ret;\n      }\n\n  // reporting and error helpers \n    function die(msg,err) {\n      if (DEBUG && err) console.warn(err);\n      msg.stack = ((DEBUG && err) || new Error()).stack.split(/\\s*\\n\\s*/g);\n      throw JSON.stringify(msg,null,2);\n    }\n\n    function s(msg) {\n      if ( DEBUG ) {\n        console.log(JSON.stringify(msg,showNodes,2));\n        console.info('.');\n      }\n    }\n\n    function showNodes(k,v) {\n      let out = v;\n      if ( T.check(T`>Node`, v) ) {\n        out = `<${v.nodeName.toLowerCase()} ${\n          !v.attributes ? '' : [...v.attributes].map(({name,value}) => `${name}='${value}'`).join(' ')}>${\n          v.nodeValue || (v.children && v.children.length <= 1 ? v.innerText : '')}`;\n      } else if ( typeof v === \"function\" ) {\n        return `${v.name || 'anon'}() { ... }`\n      }\n      return out;\n    }\n"]}