{"version":3,"sources":["common.js","t.js","types.js","r.js"],"names":["CODE","Math","random","BuiltIns","Symbol","Boolean","Number","String","Object","Set","Map","WeakMap","WeakSet","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8ClampedArray","Node","NodeList","Element","HTMLElement","Blob","ArrayBuffer","FileList","Text","HTMLDocument","Document","DocumentFragment","Error","File","Event","EventTarget","URL","DEBUG","SEALED_DEFAULT","isNone","instance","undefined","typeCache","T","parts","vals","cooked","typeName","reduce","prev","cur","i","has","TypeError","get","type","partialMatch","validate","partial","guardType","guardExists","name","spec","kind","help","verify","verifiers","sealed","specKeyPaths","allKeyPaths","sort","specKeyPathSet","bigErrors","allValid","keyPaths","every","kp","lookup","checkTypeMatch","resolved","lookupErrors","errors","push","length","keyType","Type","error","valid","validationErrors","verified","JSON","stringify","map","f","toString","join","isSumType","types","keys","t","helpMsg","e","sealValid","type_key_paths","all_key_paths","errorKeys","tkp","k","container","containerValid","containerErrors","membersValid","member","check","obj","keyPath","canBeNone","split","pathComplete","nextKey","shift","typeA","typeB","startsWith","console","option","sub","defSub","native","newType","def","defEnum","guardRedefinition","values","valueSet","exists","o","isTypeSpec","recurseObject","keyPathSet","lastLevel","levelKeys","getOwnPropertyNames","forEach","v","add","Array","isArray","warn","item","index","defOption","isUnset","maybe","defCollection","set","defTuple","pattern","specObj","key","mods","defineProperty","typeSet","cache","defOr","some","guard","originalName","mapBuiltins","constructor","defineSpecials","Function","isInteger","iterator","oName","prototype","call","replace","endsWith","self","for","TKey","THandlers","eventNames","handlerFuncs","validNames","validFuncs","func","TFuncArray","TEmptyArray","TMarkupObject","code","nodes","externals","TMarkupAttrObject","str","TBrutalLikeObject","to","update","oldVals","TBrutalObject","TBrutalArray","TSBrutalObject","handlers","TSBrutalArray","BS","SSR","Types","skip","markup","attrskip","attrmarkup","NULLFUNC","KEYMATCH","ATTRMATCH","KEYLEN","XSS","OBJ","UNSET","INSERT","NOTFOUND","loc","MOVE","frag","elem","appendChild","parentNode","insertBefore","nextSibling","replaceChild","firstChild","innerHTML","onerror","log","message","stack","isKey","isHandlers","d","R","u","X","x","p","exoteric","useCache","instanceKey","cacheKey","retVal","guardAndTransformVal","find","isCached","cached","firstCall","from","vmap","V","replaceValWithKeyAndOmitInstanceKey","toDOM","walker","document","createTreeWalker","NodeFilter","SHOW_ALL","makeUpdaters","nextNode","assign","childNodes","instances","location","options","position","toLocaleLowerCase","createDocumentFragment","n","isNode","querySelector","die","node","currentNode","nodeType","ELEMENT_NODE","handleElement","COMMENT_NODE","TEXT_NODE","handleNode","result","lengths","text","nodeValue","exec","val","replacer","makeNodeUpdater","replacers","nodeState","scope","oldVal","oldNodes","lastAnchor","newVal","getType","handleMarkupInNode","handleTextInNode","state","sameOrder","reverse","placeholderNode","summonPlaceholder","dn","diffNodes","size","nodesA","nodesB","an","valIndex","vi","originalLengthBefore","slice","lengthBefore","sum","value","correction","newValue","getAttributes","attrState","lastIndex","prepareAttributeUpdater","updateName","input","oldName","makeAttributeNameUpdater","makeAttributeValueUpdater","attr","hasAttribute","removeAttribute","trim","test","assignmentIndex","indexOf","reliablySetAttribute","updateAttrWithFuncarrayValue","updateAttrWithFunctionValue","updateAttrWithHandlersValue","updateAttrWithTextValue","nodesToStr","setAttribute","formatClassListValue","getAttribute","attributes","attrs","flags","includes","O","removeEventListener","addEventListener","splice","of","entries","eventName","funcVal","zeroWidthCorrection","newAttrValue","before","after","spacer","sibling","ph","guardEmptyHandlers","padEnd","templateEl","DOMParser","parseFromString","head","firstElementChild","HTMLTemplateElement","content","normalize","isFunc","isObject","isBrutalArray","isFuncArray","isMarkupObject","isMarkupAttrObject","isBrutal","isForgery","os","bigNodes","cloneNode","createElement","last","next","filter","newVals","updateable","didChange","ret","oldType","msg","err","s","showNodes","info","out","nodeName","toLowerCase","children","innerText"],"mappings":"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","file":"r.js","sourceRoot":"..","sourcesContent":["// common for all r submodules\n  export const CODE              = ''+Math.random();\n\n","\n  const BuiltIns = [\n    Symbol, Boolean, Number, String, Object, Set, Map, WeakMap, WeakSet,\n    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,\n    Int8Array, Int16Array, Int32Array, \n    Uint8ClampedArray, \n    Node,NodeList,Element,HTMLElement, Blob, ArrayBuffer,\n    FileList, Text, HTMLDocument, Document, DocumentFragment,\n    Error, File, Event, EventTarget, URL\n  ]\n\n  const DEBUG = false;\n  const SEALED_DEFAULT = true;\n  const isNone = instance => instance == null || instance == undefined;\n\n  const typeCache = new Map();\n\n  T.def = def;\n  T.check = check;\n  T.sub = sub;\n  T.verify = verify;\n  T.validate = validate;\n  T.partialMatch = partialMatch;\n  T.defEnum = defEnum;\n  T.defSub = defSub;\n  T.defTuple = defTuple;\n  T.defCollection = defCollection;\n  T.defOr = defOr;\n  T.option = option;\n  T.defOption = defOption;\n  T.maybe = maybe;\n  T.guard = guard;\n  T.errors = errors;\n\n  // debug\n  if ( DEBUG ) {\n    self.T = T;\n    self.typeCache = typeCache;\n  }\n\n  T[Symbol.for('jtype-system.typeCache')] = typeCache;\n\n  defineSpecials();\n  mapBuiltins();\n\n  export function T(parts, ...vals) {\n    const cooked = vals.reduce((prev,cur,i) => prev+cur+parts[i+1], parts[0]);\n    const typeName = cooked;\n    if ( !typeCache.has(typeName) ) throw new TypeError(`Cannot use type ${typeName} before it is defined.`);\n    return typeCache.get(typeName).type;\n  }\n\n  function partialMatch(type, instance) {\n    return validate(type, instance, {partial:true});\n  }\n\n  function validate(type, instance, {partial: partial = false} = {}) {\n    guardType(type);\n    guardExists(type);\n    const typeName = type.name;\n\n    const {spec,kind,help,verify,verifiers,sealed} = typeCache.get(typeName);\n\n    const specKeyPaths = spec ? allKeyPaths(spec).sort() : [];\n    const specKeyPathSet = new Set(specKeyPaths);\n\n    const bigErrors = [];\n\n    switch(kind) {\n      case \"def\": {\n        let allValid = true;\n        if ( spec ) {\n          const keyPaths = partial ? allKeyPaths(instance, specKeyPathSet) : specKeyPaths;\n          allValid = !isNone(instance) && keyPaths.every(kp => {\n            // Allow lookup errors if the type match for the key path can include None\n\n            const {resolved, errors:lookupErrors} = lookup(instance,kp,() => checkTypeMatch(lookup(spec,kp).resolved, T`None`));\n            bigErrors.push(...lookupErrors);\n\n            if ( lookupErrors.length ) return false;\n\n            const keyType = lookup(spec,kp).resolved;\n            if ( !keyType || !(keyType instanceof Type) ) {\n              bigErrors.push({\n                error: `Key path '${kp}' is not present in the spec for type '${typeName}'`\n              });\n              return false;\n            }\n\n            const {valid, errors: validationErrors} = validate(keyType, resolved);\n            bigErrors.push(...validationErrors);\n\n            return valid;\n          });\n        }\n        let verified = true;\n        if ( partial && ! spec && !!verify ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for types that` + \n            ` only use a verify function but have no spec`);\n        } else if ( verify ) {\n          try {\n            verified = verify(instance);\n            if ( ! verified ) {\n              if ( verifiers ) {\n                throw {\n                  error:`Type ${typeName} value '${JSON.stringify(instance)}' violated at least 1 verify function in:\\n${\n                    verifiers.map(f => '\\t'+(f.help||'') + ' ('+f.verify.toString()+')').join('\\n')\n                  }`\n                };\n              } else if ( type.isSumType ) {\n                throw {\n                  error: `Value '${JSON.stringify(instance)}' did not match any of: ${[...type.types.keys()].map(t => t.name)}`,\n                  verify, verifiers\n                }\n              } else {\n                let helpMsg = '';\n                if ( help ) {\n                  helpMsg = `Help: ${help}. `;\n                }\n                throw {error:`${helpMsg}Type ${typeName} Value '${JSON.stringify(instance)}' violated verify function in: ${verify.toString()}`};\n              }\n            }\n          } catch(e) {\n            bigErrors.push(e);\n            verified = false;\n          }\n        }\n        let sealValid = true;\n        if ( !!sealed && !! spec ) {\n          const type_key_paths = specKeyPaths;\n          const all_key_paths = allKeyPaths(instance, specKeyPathSet).sort();\n          sealValid  = all_key_paths.join(',') == type_key_paths.join(',');\n          if ( ! sealValid ) {\n            if ( all_key_paths.length < type_key_paths.length ) {\n              sealValid = true;\n            } else {\n              const errorKeys = [];\n              const tkp = new Set(type_key_paths); \n              for( const k of all_key_paths ) {\n                if ( ! tkp.has(k) ) {\n                  errorKeys.push({\n                    error: `Key path '${k}' is not in the spec for type ${typeName}`\n                  });\n                }\n              }\n              if ( errorKeys.length ) {\n                bigErrors.push(...errorKeys);\n              }\n            }\n          }\n        }\n        return {valid: allValid && verified && sealValid, errors: bigErrors, partial}\n      } case \"defCollection\": {\n        const {valid:containerValid, errors:containerErrors} = validate(spec.container, instance);\n        let membersValid = true;\n        let verified = true;\n\n        bigErrors.push(...containerErrors);\n        if ( partial ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for Collection types`);\n        } else {\n          if ( containerValid ) {\n             membersValid= [...instance].every(member => {\n              const {valid, errors} = validate(spec.member, member);\n              bigErrors.push(...errors);\n              return valid;\n            });\n          }\n          if ( verify ) {\n            try {\n              verified = verify(instance);\n            } catch(e) {\n              bigErrors.push(e);\n              verified = false;\n            }\n          }\n        }\n          \n        return {valid:containerValid && membersValid && verified, errors:bigErrors};\n      } default: {\n        throw new TypeError(`Checking for type kind ${kind} is not yet implemented.`);\n      }\n    }\n  }\n\n  function check(...args) {\n    return validate(...args).valid;\n  }\n\n  function lookup(obj, keyPath, canBeNone) {\n    if ( isNone(obj) ) throw new TypeError(`Lookup requires a non-unset object.`);\n\n    if ( !keyPath ) throw new TypeError(`keyPath must not be empty`);\n\n\n    const keys = keyPath.split(/\\./g);\n    const pathComplete = [];\n    const errors = [];\n\n    let resolved = obj;\n\n    while(keys.length) {\n      const nextKey = keys.shift();\n      resolved = resolved[nextKey];\n      pathComplete.push(nextKey);\n      if ( (resolved === null || resolved === undefined) ) {\n        if ( keys.length ) {\n          errors.push({\n            error: \n              `Lookup on key path '${keyPath}' failed at '` + \n              pathComplete.join('.') +\n              `' when ${resolved} was found at '${nextKey}'.` \n          });\n        } else if ( !!canBeNone && canBeNone() ) {\n          resolved = undefined;\n        } else {\n          errors.push({\n            error: \n              `Resolution on key path '${keyPath}' failed` + \n              `when ${resolved} was found at '${nextKey}' and the Type of this` +\n              `key's value cannot be None.`\n          });\n        }\n        break;\n      }\n    }\n    return {resolved,errors};\n  }\n\n  function checkTypeMatch(typeA, typeB) {\n    guardType(typeA);\n    guardExists(typeA);\n    guardType(typeB);\n    guardExists(typeB);\n\n    if ( typeA === typeB ) {\n      return true;\n    } else if ( typeA.isSumType && typeA.types.has(typeB) ) {\n      return true;\n    } else if ( typeB.isSumType && typeB.types.has(typeA) ) {\n      return true;\n    } else if ( typeA.name.startsWith('?') && typeB == T`None` ) {\n      return true;\n    } else if ( typeB.name.startsWith('?') && typeA == T`None` ) {\n      return true;\n    }\n\n    if ( typeA.name.startsWith('>') || typeB.name.startsWith('>') ) {\n      console.error(new Error(`Check type match has not been implemented for derived//sub types yet.`));\n    }\n\n    return false;\n  }\n\n  function option(type) {\n    return T`?${type.name}`;\n  }\n\n  function sub(type) {\n    return T`>${type.name}`;\n  }\n\n  function defSub(type, spec, {verify: verify = undefined, help:help = ''} = {}, name = '') {\n    guardType(type);\n    guardExists(type);\n\n    let verifiers;\n\n    if ( ! verify ) {\n      verify = () => true;\n    } \n\n    if ( type.native ) {\n      verifiers = [ {help,verify} ];\n      verify = i => i instanceof type.native;\n      const helpMsg = `Needs to be of type ${type.native.name}. ${help||''}`;\n      verifiers.push({help:helpMsg,verify});\n    }\n\n    const newType = def(`${name}>${type.name}`, spec, {verify,help, verifiers});\n    return newType;\n  }\n\n  function defEnum(name, ...values) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n    \n    const valueSet = new Set(values);\n    const verify = i => valueSet.has(i);\n    const help = `Value of Enum type ${name} must be one of ${values.join(',')}`;\n\n    return def(name, null, {verify,help});\n  }\n\n  function exists(name) {\n    return typeCache.has(name);\n  }\n\n  function guardRedefinition(name) {\n    if ( exists(name) ) throw new TypeError(`Type ${name} cannot be redefined.`);\n  }\n\n  function allKeyPaths(o, specKeyPaths) {\n    const isTypeSpec = ! specKeyPaths;\n    const keyPaths = new Set();\n    return recurseObject(o, keyPaths, '');\n\n    function recurseObject(o, keyPathSet, lastLevel = '') {\n      const levelKeys = Object.getOwnPropertyNames(o); \n      const keyPaths = levelKeys\n        .map(k => lastLevel + (lastLevel.length ? '.' : '') + k)\n      levelKeys.forEach((k,i) => {\n        const v = o[k];\n        if ( isTypeSpec ) {\n          if ( v instanceof Type ) {\n            keyPathSet.add(keyPaths[i]);\n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              DEBUG && console.warn({o,v,keyPathSet, lastLevel});\n              throw new TypeError(`We don't support Types that use Arrays as structure, just yet.`); \n            }\n          } else {\n            throw new TypeError(`Spec cannot contain leaf values that are not valid Types`);\n          }\n        } else {\n          if ( specKeyPaths.has(keyPaths[i]) ) {\n            keyPathSet.add(keyPaths[i]); \n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              v.forEach((item,index) => recurseObject(item, keyPathSet, keyPaths[i] + '.' + index));\n              //throw new TypeError(`We don't support Instances that use Arrays as structure, just yet.`); \n            }\n          } else {\n            //console.warn(\"Spec has no such key\",  keyPaths[i]);\n            keyPathSet.add(keyPaths[i]);\n          }\n        }\n      });\n      return [...keyPathSet];\n    }\n  }\n\n  function defOption(type) {\n    guardType(type);\n    const typeName = type.name;\n    return T.def(`?${typeName}`, null, {verify: i => isUnset(i) || T.check(type,i)});\n  }\n\n  function maybe(type) {\n    try {\n      return defOption(type);\n    } catch(e) {\n      // console.log(`Option Type ${type.name} already declared.`, e);\n    }\n    return T`?${type.name}`;\n  }\n\n  function verify(...args) { return check(...args); }\n\n  function defCollection(name, {container, member}, {sealed: sealed = SEALED_DEFAULT, verify: verify = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !container || !member ) throw new TypeError(`Type must be specified.`);\n    guardRedefinition(name);\n\n    const kind = 'defCollection';\n    const t = new Type(name);\n    const spec = {kind, spec: { container, member}, verify, sealed, type: t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function defTuple(name, {pattern}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !pattern ) throw new TypeError(`Type must be specified.`);\n    const kind = 'def';\n    const specObj = {};\n    pattern.forEach((type,key) => specObj[key] = type);\n    const t = new Type(name);\n    const spec = {kind, spec: specObj, type:t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function Type(name, mods = {}) {\n    if ( ! new.target ) throw new TypeError(`Type with new only.`);\n    Object.defineProperty(this,'name', {get: () => name});\n    this.typeName = name;\n\n    if ( mods.types ) {\n      const {types} = mods;\n      const typeSet = new Set(types);\n      Object.defineProperty(this,'isSumType', {get: () => true});\n      Object.defineProperty(this,'types', {get: () => typeSet});\n    }\n\n    if ( mods.native ) {\n      const {native} = mods;\n      Object.defineProperty(this,'native', {get: () => native});\n    }\n  }\n\n  Type.prototype.toString = function () {\n    return `${this.typeName} Type`;\n  };\n\n  function def(name, spec, {help:help = '', verify:verify = undefined, sealed:sealed = undefined, types:types = undefined, verifiers:verifiers = undefined, native:native = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n\n    if ( name.startsWith('?') ) {\n      if ( spec ) {\n        throw new TypeError(`Option type can not have a spec.`);\n      } \n\n      if ( ! verify(null) ) {\n        throw new TypeError(`Option type must be OK to be unset.`);\n      }\n    }\n\n    const kind = 'def';\n    if ( sealed === undefined ) {\n      sealed = true;\n    }\n    const t = new Type(name, {types, native});\n    const cache = {spec,kind,help,verify,verifiers,sealed,types,native,type:t};\n    typeCache.set(name, cache);\n    return t;\n  }\n\n  function defOr(name, ...types) {\n    return T.def(name, null, {types, verify: i => types.some(t => check(t,i))});\n  }\n\n  function guard(type, instance) {\n    guardType(type);\n    guardExists(type);\n    const {valid, errors} = validate(type, instance);\n    if ( ! valid ) throw new TypeError(`Type ${type} requested, but item is not of that type: ${errors.join(', ')}`);\n  }\n\n  function guardType(t) {\n    //console.log(t);\n    if ( !(t instanceof Type) ) throw new TypeError(`Type must be a valid Type object.`);\n  }\n\n  function guardExists(t) {\n    const name = originalName(t);\n    if ( ! exists(name) ) throw new TypeError(`Type must exist. Type ${name} has not been defined.`);\n  }\n\n  function errors(...args) {\n    return validate(...args).errors;\n  }\n\n  function mapBuiltins() {\n    BuiltIns.forEach(t => def(originalName(t), null, {native: t, verify: i => originalName(i.constructor) === originalName(t)}));  \n    BuiltIns.forEach(t => defSub(T`${originalName(t)}`));  \n  }\n\n  function defineSpecials() {\n    T.def(`Any`, null, {verify: () => true});\n    T.def(`Some`, null, {verify: i => !isUnset(i)});\n    T.def(`None`, null, {verify: i => isUnset(i)});\n    T.def(`Function`, null, {verify: i => i instanceof Function});\n    T.def(`Integer`, null, {verify: i => Number.isInteger(i)});\n    T.def(`Array`, null, {verify: i => Array.isArray(i)});\n    T.def(`Iterable`, null, {verify: i => i[Symbol.iterator] instanceof Function});\n  }\n\n  function isUnset(i) {\n    return i === null || i === undefined;\n  }\n\n  function originalName(t) {\n    if (!!t && t.name) {\n      return t.name;\n    } \n    const oName = Object.prototype.toString.call(t).replace(/\\[object |\\]/g, '');\n    if ( oName.endsWith('Constructor') ) {\n      return oName.replace(/Constructor$/,'');\n    }\n    return oName;\n  }\n\n","// types\n  import {T} from './t.js';\n  import {CODE} from './common.js';\n\n  // T\n\n    export default T;\n\n  // Both SSR and Browser\n\n    export const TKey = T.def('Key', {\n      key: T.defOr('ValidKey', T`String`, T`Number`)\n    });\n\n    export const THandlers = T.def('Handlers', null, {verify: i => {\n      const validObject = T.check(T`Object`, i);\n\n      if ( ! validObject ) return false;\n\n      const eventNames = Object.keys(i);\n      const handlerFuncs = Object.values(i);\n      const validNames = eventNames.every(name => T.check(T`String`, name));\n      const validFuncs = handlerFuncs.every(func => T.check(T`Function`, func));\n      const valid = validNames && validFuncs;\n\n      return valid;\n    }});\n\n    export const TFuncArray = T.defCollection('FuncArray', {\n      container: T`Array`,\n      member: T`Function`\n    });\n\n    export const TEmptyArray = T.def('EmptyArray', null, {verify: i => Array.isArray(i) && i.length == 0});\n\n    export const TMarkupObject = T.def('MarkupObject', {\n      type: T`String`,\n      code: T`String`,\n      nodes: T`Array`,\n      externals: T`Array`,\n    }, {verify: v => v.type == 'MarkupObject' && v.code == CODE});\n\n    export const TMarkupAttrObject = T.def('MarkupAttrObject', {\n      type: T`String`,\n      code: T`String`,\n      str: T`String`\n    }, {verify: v => v.type == 'MarkupAttrObject' && v.code == CODE});\n\n  // Browser side\n\n    export const TBrutalLikeObject = T.def('BrutalLikeObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`,\n      oldVals: T`Array`\n    });\n\n    export const TBrutalObject = T.def('BrutalObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`,\n      oldVals: T`Array`\n    }, {verify: v => verify(v)});\n\n    export const TBrutalArray = T.defCollection('BrutalArray', {\n      container: T`Array`,\n      member: T`BrutalObject`\n    });\n\n  // SSR\n\n    export const TSBrutalObject = T.def('SBrutalObject', {\n      str: T`String`,\n      handlers: THandlers\n    });\n\n    export const TSBrutalArray = T.defCollection('SBrutalArray', {\n      container: T`Array`,\n      member: T`SBrutalObject`\n    });\n\n  // export\n\n  export const BS = {TKey,THandlers,TFuncArray,TBrutalObject,TBrutalLikeObject,TBrutalArray};\n\n  export const SSR = {TKey,THandlers,TFuncArray,TSBrutalObject,TSBrutalArray};\n\n  export const Types = {BS,SSR};\n\n\n  // verify function \n    function verify(v) {\n      return CODE === v.code;\n    }\n\n","// r.js\n  // imports\n    import {CODE} from './common.js';\n    import T from './types.js';\n\n  // backwards compatible alias\n    const skip = markup;\n    const attrskip = attrmarkup;\n\n  // constants\n    const DEBUG             = false;\n    const NULLFUNC          = () => void 0;\n    /* eslint-disable no-useless-escape */\n    const KEYMATCH          = /(?:<!\\-\\-)?(key\\d+)(?:\\-\\->)?/gm;\n    /* eslint-enable no-useless-escape */\n    const ATTRMATCH         = /\\w+=/;\n    const KEYLEN            = 20;\n    const XSS               = () => `Possible XSS / object forgery attack detected. ` +\n                              `Object code could not be verified.`;\n    const OBJ               = () => `Object values not allowed here.`;\n    const UNSET             = () => `Unset values not allowed here.`;\n    const INSERT            = () => `Error inserting template into DOM. ` +\n      `Position must be one of: ` +\n      `replace, beforebegin, afterbegin, beforeend, innerhtml, afterend`;\n    const NOTFOUND          = loc => `Error inserting template into DOM. ` +\n      `Location ${loc} was not found in the document.`;\n    const MOVE              = new class {\n      beforeend   (frag,elem) { elem.appendChild(frag) }\n      beforebegin (frag,elem) { elem.parentNode.insertBefore(frag,elem) }\n      afterend    (frag,elem) { elem.parentNode.insertBefore(frag,elem.nextSibling) }\n      replace     (frag,elem) { elem.parentNode.replaceChild(frag,elem) }\n      afterbegin  (frag,elem) { elem.insertBefore(frag,elem.firstChild) }\n      innerhtml   (frag,elem) { elem.innerHTML = ''; elem.appendChild(frag) }\n    };\n\n  // logging\n    self.onerror = (...v) => (console.log(v, v[0]+'', v[4] && v[4].message, v[4] && v[4].stack), true);\n\n  // type functions\n    const isKey             = v => T.check(T`Key`, v);\n    const isHandlers        = v => T.check(T`Handlers`, v);\n\n  // cache \n    const cache = {};\n    // deux\n    export const d = R;\n    export const e = d;\n    export const u = X;\n    export const x = u;\n\n  // main exports \n    Object.assign(R,{s,attrskip,skip,attrmarkup,markup,guardEmptyHandlers,die});\n\n    if ( DEBUG ) {\n      Object.assign(self, {d,u,T}); \n    }\n\n    export function R(p,...v) {\n      return exoteric(p,v);\n    }\n\n    export function X(p,...v) {\n      return exoteric(p,v,{useCache:false});\n    }\n\n  // main function (TODO: should we refactor?)\n    function exoteric(p,v,{useCache:useCache=true}={}) {\n      const retVal = {};\n      let instanceKey, cacheKey;\n\n      v = v.map(guardAndTransformVal);\n\n      if ( useCache ) {\n        ({key:instanceKey} = (v.find(isKey) || {}));\n        cacheKey = p.join('<link rel=join>');\n        const {cached,firstCall} = isCached(cacheKey,v,instanceKey);\n       \n        if ( ! firstCall ) {\n          cached.update(v);\n          return cached;\n        } else {\n          retVal.oldVals = Array.from(v);\n        }\n      } else {\n        retVal.oldVals = Array.from(v);\n      }\n      \n      // compile the template into an updater\n\n      p = [...p]; \n      const vmap = {};\n      const V = v.map(replaceValWithKeyAndOmitInstanceKey(vmap));\n      const externals = [];\n      let str = '';\n\n      while( p.length > 1 ) str += p.shift() + V.shift();\n      str += p.shift();\n\n      const frag = toDOM(str);\n      const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ALL);\n\n      do {\n        makeUpdaters({walker,vmap,externals});\n      } while(walker.nextNode())\n\n      Object.assign(retVal, {\n        externals,\n        v:Object.values(vmap),\n        to,\n        update,\n        code:CODE,\n        nodes:[...frag.childNodes]\n      });\n\n      if ( useCache ) {\n        if ( instanceKey ) {\n          cache[cacheKey].instances[instanceKey] = retVal;\n        } else {\n          cache[cacheKey] = retVal;\n        }\n      }\n\n      return retVal;\n    }\n\n  // to function\n    function to(location, options) {\n      const position = (options || 'replace').toLocaleLowerCase();\n      const frag = document.createDocumentFragment();\n      this.nodes.forEach(n => frag.appendChild(n));\n      const isNode = T.check(T`>Node`, location);\n      const elem = isNode ? location : document.querySelector(location);\n      try {\n        MOVE[position](frag,elem);\n      } catch(e) {\n        DEBUG && console.log({location,options,e,elem,isNode});\n        DEBUG && console.warn(e);\n        switch(e.constructor && e.constructor.name) {\n          case \"DOMException\":      die({error: INSERT()},e);             break;\n          case \"TypeError\":         die({error: NOTFOUND(location)},e);   break; \n          default:                  throw e;\n        }\n      }\n      while(this.externals.length) {\n        this.externals.shift()();\n      }\n    }\n\n  // update functions\n    function makeUpdaters({walker,vmap,externals}) {\n      const node = walker.currentNode;\n      switch( node.nodeType ) {\n        case Node.ELEMENT_NODE:\n          handleElement({node,vmap,externals}); break;\n        case Node.COMMENT_NODE:\n        case Node.TEXT_NODE:\n          handleNode({node,vmap,externals}); break;\n      }\n    }\n\n    function handleNode({node,vmap,externals}) {\n      const lengths = [];\n      const text = node.nodeValue; \n      let result = KEYMATCH.exec(text);\n      while ( result ) {\n        const {index} = result;\n        const key = result[1];\n        const val = vmap[key];\n        const replacer = makeNodeUpdater({node,index,lengths,val});\n        externals.push(() => replacer(val.val));\n        val.replacers.push( replacer );\n        result = KEYMATCH.exec(text);\n      }\n    }\n\n    // node functions\n      function makeNodeUpdater(nodeState) {\n        const {node} = nodeState;\n        const scope = Object.assign({}, nodeState, {\n          oldVal: {length: KEYLEN},\n          oldNodes: [node],\n          lastAnchor: node,\n        });\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"markupobject\": \n            case \"brutalobject\":\n              handleMarkupInNode(newVal, scope); break;\n            default:\n              handleTextInNode(newVal, scope); break;\n          }\n        };\n      }\n\n      function handleMarkupInNode(newVal, state) {\n        let {oldNodes,lastAnchor} = state;\n        if ( newVal.nodes.length ) {\n          if ( sameOrder(oldNodes,newVal.nodes) ) {\n            // do nothing\n          } else {\n            Array.from(newVal.nodes).reverse().forEach(n => {\n              lastAnchor.parentNode.insertBefore(n,lastAnchor.nextSibling);\n              state.lastAnchor = lastAnchor.nextSibling;\n            });\n            state.lastAnchor = newVal.nodes[0];\n          }\n        } else {\n          const placeholderNode = summonPlaceholder(lastAnchor);\n          lastAnchor.parentNode.insertBefore(placeholderNode,lastAnchor.nextSibling);\n          state.lastAnchor = placeholderNode;\n        }\n        // MARK: Unbond event might be relevant here.\n        const dn = diffNodes(oldNodes,newVal.nodes);\n        if ( dn.size ) {\n          const f = document.createDocumentFragment();\n          dn.forEach(n => f.appendChild(n));\n        }\n        state.oldNodes = newVal.nodes || [lastAnchor];\n        while ( newVal.externals.length ) {\n          const func = newVal.externals.shift();\n          func();\n        } \n      }\n\n      function sameOrder(nodesA, nodesB) {\n        if ( nodesA.length != nodesB.length ) return false;\n\n        return Array.from(nodesA).every((an,i) => an == nodesB[i]);\n      }\n\n      function handleTextInNode(newVal, state) {\n        let {oldVal, index, val, lengths, node} = state;\n\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n        const value = node.nodeValue;\n\n        lengths[valIndex] = newVal.length;\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = value.slice(0,index+correction);\n        const after = value.slice(index+correction+oldVal.length);\n\n        const newValue = before + newVal + after;\n\n        node.nodeValue = newValue;\n\n        state.oldVal = newVal;\n      }\n\n    // element attribute functions\n      function handleElement({node,vmap,externals}) {\n        getAttributes(node).forEach(({name,value} = {}) => {\n          const attrState = {node, vmap, externals, name, lengths: []};\n\n          KEYMATCH.lastIndex = 0;\n          let result = KEYMATCH.exec(name);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:true});\n            result = KEYMATCH.exec(name);\n          }\n\n          KEYMATCH.lastIndex = 0;\n          result = KEYMATCH.exec(value);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:false});\n            result = KEYMATCH.exec(value);\n          }\n        });\n      }\n\n      function prepareAttributeUpdater(result, attrState, {updateName}) {\n        const {index, input} = result;\n        const scope = Object.assign({}, attrState, {\n          index, input, updateName, \n          val: attrState.vmap[result[1]],\n          oldVal: {length: KEYLEN},\n          oldName: attrState.name,\n        });\n\n        let replacer;\n        if ( updateName ) {\n          replacer = makeAttributeNameUpdater(scope);\n        } else {\n          replacer = makeAttributeValueUpdater(scope);\n        }\n\n        scope.externals.push(() => replacer(scope.val.val));\n        scope.val.replacers.push( replacer );\n      }\n\n      // FIXME: needs to support multiple replacements just like value\n      // QUESTION: why is the variable oldName so required here, why can't we call it oldVal?\n      // if we do it breaks, WHY?\n      function makeAttributeNameUpdater(scope) {\n        let {oldName,node,val} = scope;\n        return (newVal) => {\n          if ( oldName == newVal ) return;\n          val.val = newVal;\n          const attr = node.hasAttribute(oldName) ? oldName : ''\n          if ( attr !== newVal ) {\n            if ( attr ) {\n              node.removeAttribute(oldName);\n              node[oldName] = undefined;\n            }\n            if ( newVal ) {\n              newVal = newVal.trim();\n\n              let name = newVal, value = undefined;\n\n              if( ATTRMATCH.test(newVal) ) {\n                const assignmentIndex = newVal.indexOf('='); \n                ([name,value] = [newVal.slice(0,assignmentIndex), newVal.slice(assignmentIndex+1)]);\n              }\n\n              reliablySetAttribute(node, name, value);\n            }\n            oldName = newVal;\n          }\n        };\n      }\n\n      function makeAttributeValueUpdater(scope) {\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"funcarray\":       updateAttrWithFuncarrayValue(newVal, scope); break;\n            case \"function\":        updateAttrWithFunctionValue(newVal, scope); break;\n            case \"handlers\":        updateAttrWithHandlersValue(newVal, scope); break;\n            case \"markupobject\":     \n            case \"brutalobject\": \n              newVal = nodesToStr(newVal.nodes); \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-disable no-fallthrough */\n            case \"markupattrobject\":  // deliberate fall through\n              newVal = newVal.str;\n            default:                \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-enable no-fallthrough */\n          }\n        };\n      }\n\n  // helpers\n    function getAttributes(node) {\n      if ( ! node.hasAttribute ) return [];\n\n      // for parity with classList.add (which trims whitespace)\n        // otherwise once the classList manipulation happens\n        // our indexes for replacement will be off\n      if ( node.hasAttribute('class') ) {\n        node.setAttribute('class', formatClassListValue(node.getAttribute('class')));\n      }\n      if ( !! node.attributes && Number.isInteger(node.attributes.length) ) return Array.from(node.attributes);\n      const attrs = [];\n      for ( const name of node ) {\n        if ( node.hasAttribute(name) ) {\n          attrs.push({name, value:node.getAttribute(name)});\n        }\n      }\n      return attrs;\n    }\n\n    function updateAttrWithFunctionValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          node.removeEventListener(name, oldVal, flags);\n        }\n        node.addEventListener(name, newVal, flags); \n      } else {\n        if ( oldVal ) {\n          const index = externals.indexOf(oldVal);\n          if ( index >= 0 ) {\n            externals.splice(index,1);\n          }\n        }\n        externals.push(() => newVal(node)); \n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithFuncarrayValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( oldVal && ! Array.isArray(oldVal) ) {\n        oldVal = [oldVal]; \n      }\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          oldVal.forEach(of => node.removeEventListener(name, of, flags));\n        }\n        newVal.forEach(f => node.addEventListener(name, f, flags));\n      } else {\n        if ( oldVal ) {\n          oldVal.forEach(of => {\n            const index = externals.indexOf(of);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          });\n        }\n        newVal.forEach(f => externals.push(() => f(node)));\n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithHandlersValue(newVal, scope) {\n      let {oldVal,node,externals,} = scope;\n      if ( !!oldVal && T.check(T`Handlers`, oldVal) ) {\n        Object.entries(oldVal).forEach(([eventName,funcVal]) => {\n          if ( eventName !== 'bond' ) {\n            let flags = {};\n            if ( eventName.includes(':') ) {\n              ([eventName, ...flags] = eventName.split(':'));\n              flags = flags.reduce((O,f) => {\n                O[f] = true;\n                return O;\n              }, {});\n            }\n            console.log(eventName, funcVal, flags);\n            node.removeEventListener(eventName, funcVal, flags); \n          } else {\n            const index = externals.indexOf(funcVal);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          }\n        });\n      }\n      Object.entries(newVal).forEach(([eventName,funcVal]) => {\n        if ( eventName !== 'bond' ) {\n          let flags = {};\n          if ( eventName.includes(':') ) {\n            ([eventName, ...flags] = eventName.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          node.addEventListener(eventName, funcVal, flags); \n        } else {\n          externals.push(() => funcVal(node)); \n        }\n      });\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithTextValue(newVal, scope) {\n      let {oldVal,node,index,name,val,lengths} = scope;\n      let zeroWidthCorrection = 0;\n      const valIndex = val.vi;\n      const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        \n      // we need to trim newVal to have parity with classlist add\n        // the reason we have zeroWidthCorrection = -1\n        // is because the classList is a set of non-zero width tokens\n        // separated by spaces\n        // when we have a zero width token, we have two adjacent spaces\n        // which, by virtue of our other requirement, gets replaced by a single space\n        // effectively elliding out our replacement location\n        // in order to keep our replacement location in tact\n        // we need to compensate for the loss of a token slot (effectively a token + a space)\n        // and having a -1 correction effectively does this.\n      if ( name == \"class\" ) {\n        newVal = newVal.trim();\n        if ( newVal.length == 0 ) {\n          zeroWidthCorrection = -1;\n        }\n        scope.val.val = newVal;\n      }\n      lengths[valIndex] = newVal.length + zeroWidthCorrection;\n      let attr = node.getAttribute(name);\n\n      const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n\n      const correction = lengthBefore-originalLengthBefore;\n      const before = attr.slice(0,index+correction);\n      const after = attr.slice(index+correction+oldVal.length);\n\n      let newAttrValue;\n      \n      if ( name == \"class\" ) {\n        const spacer = oldVal.length == 0 ? ' ' : '';\n        newAttrValue = before + spacer + newVal + spacer + after;\n      } else {\n        newAttrValue = before + newVal + after;\n      }\n\n      DEBUG && console.log(JSON.stringify({\n        newVal,\n        valIndex,\n        lengths,\n        attr,\n        lengthBefore,\n        originalLengthBefore,\n        correction,\n        before,\n        after,\n        newAttrValue\n      }, null, 2));\n\n      reliablySetAttribute(node, name, newAttrValue);\n\n      scope.oldVal = newVal;\n    }\n\n    function reliablySetAttribute(node, name, value ) {\n      if (  name == \"class\" ) {\n        value = formatClassListValue(value);\n      }\n\n      try {\n        node.setAttribute(name,value);\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n\n      try {\n        node[name] = value == undefined ? true : value;\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n    }\n\n    function getType(val) {\n      const type = T.check(T`Function`, val) ? 'function' :\n        T.check(T`Handlers`, val) ? 'handlers' : \n        T.check(T`BrutalObject`, val) ? 'brutalobject' : \n        T.check(T`MarkupObject`, val) ? 'markupobject' :\n        T.check(T`MarkupAttrObject`, val) ? 'markupattrobject' :\n        T.check(T`BrutalArray`, val) ? 'brutalarray' : \n        T.check(T`FuncArray`, val) ? 'funcarray' : \n        'default'\n      ;\n      return type;\n    }\n\n    function summonPlaceholder(sibling) {\n      let ph = [...sibling.parentNode.childNodes].find(\n        node => node.nodeType == Node.COMMENT_NODE && node.nodeValue == 'brutal-placeholder' );\n      if ( ! ph ) {\n        ph = toDOM(`<!--brutal-placeholder-->`).firstChild;\n      }\n      return ph;\n    }\n\n    // cache helpers\n      // FIXME: function needs refactor\n      function isCached(cacheKey,v,instanceKey) {\n        let firstCall;\n        let cached = cache[cacheKey];\n        if ( cached == undefined ) {\n          cached = cache[cacheKey] = {};\n          if ( instanceKey ) {\n            cached.instances = {};\n            cached = cached.instances[instanceKey] = {};\n          }\n          firstCall = true;\n        } else {\n          if ( instanceKey ) {\n            if ( ! cached.instances ) {\n              cached.instances = {};\n              firstCall = true;\n            } else {\n              cached = cached.instances[instanceKey];\n              if ( ! cached ) {\n                firstCall = true;\n              } else {\n                firstCall = false;\n              }\n            }\n          } else {\n            firstCall = false;\n          }\n        }\n        return {cached,firstCall};\n      }\n\n    // Markup helpers\n      // Returns an object that Brutal treats as markup,\n      // even tho it is NOT a Brutal Object (defined with R/X/$)\n      // And even tho it is in the location of a template value replacement\n      // Which would normally be the treated as String\n      function markup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        const frag = toDOM(str);\n        const retVal = {\n          type: 'MarkupObject',\n          code:CODE,\n          nodes:[...frag.childNodes],\n          externals: []\n        };\n        return retVal;\n      }\n\n      // Returns an object that Brutal treats, again, as markup\n      // But this time markup that is OKAY to have within a quoted attribute\n      function attrmarkup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        str = str.replace(/\"/g,'&quot;');\n        const retVal = {\n          type: 'MarkupAttrObject',\n          code: CODE,\n          str\n        };\n        return retVal;\n      }\n\n      function guardEmptyHandlers(val) {\n        if ( Array.isArray(val) ) {\n          if ( val.length == 0 ) {\n            return [NULLFUNC]\n          } \n          return val;\n        } else {\n          if ( T.check(T`None`, val) ) {\n            return NULLFUNC;\n          }\n        }\n      }\n\n    // other helpers\n      function formatClassListValue(value) {\n        value = value.trim();\n        value = value.replace(/\\s+/g, ' ');\n        return value;\n      }\n\n      function replaceValWithKeyAndOmitInstanceKey(vmap) {\n        return (val,vi) => {\n          // omit instance key\n          if ( T.check(T`Key`, val) ) {\n            return '';\n          }\n          const key = ('key'+Math.random()).replace('.','').padEnd(KEYLEN,'0').slice(0,KEYLEN);\n          let k = key;\n          if ( T.check(T`BrutalObject`, val) || T.check(T`MarkupObject`, val) ) {\n            k = `<!--${k}-->`;\n          }\n          vmap[key.trim()] = {vi,val,replacers:[]};\n          return k;\n        };\n      }\n\n      function toDOM(str) {\n        const templateEl = (new DOMParser).parseFromString(\n          `<template>${str}</template>`,\"text/html\"\n        ).head.firstElementChild;\n        let f;\n        if ( templateEl instanceof HTMLTemplateElement ) { \n          f = templateEl.content;\n          f.normalize();\n          return f;\n        } else {\n          throw new TypeError(`Could not find template element after parsing string to DOM:\\n=START=\\n${str}\\n=END=`);\n        }\n      }\n\n      function guardAndTransformVal(v) {\n        const isFunc          = T.check(T`Function`, v);\n        const isUnset         = T.check(T`None`, v);\n        const isObject        = T.check(T`Object`, v);\n        const isBrutalArray   = T.check(T`BrutalArray`, v);\n        const isFuncArray     = T.check(T`FuncArray`, v);\n        const isMarkupObject    = T.check(T`MarkupObject`, v);\n        const isMarkupAttrObject= T.check(T`MarkupAttrObject`, v);\n        const isBrutal        = T.check(T`BrutalObject`, v);\n        const isForgery       = T.check(T`BrutalLikeObject`, v)  && !isBrutal; \n\n        if ( isFunc )         return v;\n        if ( isBrutal )       return v;\n        if ( isKey(v) )       return v;\n        if ( isHandlers(v) )  return v;\n        if ( isBrutalArray )  return join(v); \n        if ( isFuncArray )    return v;\n        if ( isMarkupObject )   return v;\n        if ( isMarkupAttrObject)return v;\n        if ( isUnset )        die({error: UNSET()});\n        if ( isForgery )      die({error: XSS()});\n        if ( isObject )       die({error: OBJ()});\n\n        return v+'';\n      }\n\n      function join(os) {\n        const externals = [];\n        const bigNodes = [];\n        const v = [];\n        const oldVals = [];\n        os.forEach(o => {\n          //v.push(...o.v); \n          //oldVals.push(...o.oldVals);\n          externals.push(...o.externals);\n          bigNodes.push(...o.nodes);\n        });\n        DEBUG && console.log({oldVals,v});\n        const retVal = {v,code:CODE,oldVals,nodes:bigNodes,to,update,externals};\n        return retVal;\n      }\n\n      function nodesToStr(nodes) {\n        const frag = document.createDocumentFragment();\n        nodes.forEach(n => frag.appendChild(n.cloneNode(true)));\n        const container = document.createElement('body');\n        container.appendChild(frag);\n        return container.innerHTML;\n      }\n\n      function diffNodes(last,next) {\n        last = new Set(last);\n        next = new Set(next);\n        return new Set([...last].filter(n => !next.has(n)));\n      }\n\n      function update(newVals) {\n        const updateable = this.v.filter(({vi}) => didChange(newVals[vi], this.oldVals[vi]));\n        DEBUG && console.log({updateable, oldVals:this.oldVals, newVals});\n        updateable.forEach(({vi,replacers}) => replacers.forEach(f => f(newVals[vi])));\n        this.oldVals = Array.from(newVals);\n      }\n\n      function didChange(oldVal, newVal) {\n        DEBUG && console.log({oldVal,newVal});\n        const [oldType, newType] = [oldVal, newVal].map(getType); \n        let ret;\n        if ( oldType != newType ) {\n          ret =  true;\n        } else {\n          switch(oldType) {\n            case \"brutalobject\":\n              // the brutal object is returned by a view function\n              // which has already called its updaters and checked its slot values\n              // to determine and show changes\n              // except in the case of a list of nodes\n              ret = true;\n              break;\n            /* eslint-disable no-fallthrough */\n            case \"funcarray\":\n            case \"function\":\n              // hard to equate even if same str value as scope could be diff\n              ret = true;\n              break;\n            case \"brutalarray\":\n              // need to do array dif so don't do here\n              ret = true;\n              break;\n            case \"markupattrobject\":\n            case \"markupobject\":\n              // need to check multiple things\n              ret = true;\n              break;\n            default:\n              ret = JSON.stringify(oldVal) !== JSON.stringify(newVal);\n              break;\n            /* eslint-enable no-fallthrough */\n          }\n        }\n\n        DEBUG && console.log({ret});\n        return ret;\n      }\n\n  // reporting and error helpers \n    function die(msg,err) {\n      if (DEBUG && err) console.warn(err);\n      msg.stack = ((DEBUG && err) || new Error()).stack.split(/\\s*\\n\\s*/g);\n      throw JSON.stringify(msg,null,2);\n    }\n\n    function s(msg) {\n      if ( DEBUG ) {\n        console.log(JSON.stringify(msg,showNodes,2));\n        console.info('.');\n      }\n    }\n\n    function showNodes(k,v) {\n      let out = v;\n      if ( T.check(T`>Node`, v) ) {\n        out = `<${v.nodeName.toLowerCase()} ${\n          !v.attributes ? '' : [...v.attributes].map(({name,value}) => `${name}='${value}'`).join(' ')}>${\n          v.nodeValue || (v.children && v.children.length <= 1 ? v.innerText : '')}`;\n      } else if ( typeof v === \"function\" ) {\n        return `${v.name || 'anon'}() { ... }`\n      }\n      return out;\n    }\n"]}